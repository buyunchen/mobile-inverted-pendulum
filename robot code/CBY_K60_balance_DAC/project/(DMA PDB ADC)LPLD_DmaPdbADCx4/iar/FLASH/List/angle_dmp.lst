###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.70.2.6274/W32 for ARM      03/Nov/2019  15:51:59 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Buyun\Progress\memristor based control\mcu            #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\app\angle_dmp.c                     #
#    Command line =  "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\app\angle_dmp.c" -D LPLD_K60 -lCN   #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\" -lB                #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\" -o                 #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5_2\arm\INC\c\DLib_Config_Normal.h" -I                 #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\app\" -I                     #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\CPU\" -I           #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\common\" -I        #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\" -I          #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\HW\" -I       #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\DEV\" -I      #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\uCOS-II\Ports\"    #
#                    -I "D:\Buyun\Progress\memristor based control\mcu        #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\uCOS-II\Source\"   #
#                    -I "D:\Buyun\Progress\memristor based control\mcu        #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\FatFs\" -I         #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\FatFs\option\" -I  #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\common\" -I    #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\driver\" -I    #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\descriptor\"   #
#                    -I "D:\Buyun\Progress\memristor based control\mcu        #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\class\" -Ol    #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM4      #
#    List file    =  D:\Buyun\Progress\memristor based control\mcu            #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\angle_dmp.lst        #
#    Object file  =  D:\Buyun\Progress\memristor based control\mcu            #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\Obj\angle_dmp.o           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Buyun\Progress\memristor based control\mcu code\paper code\0.1ms control period\test code\CBY_K60_balance_DAC\project\(DMA PDB ADC)LPLD_DmaPdbADCx4\app\angle_dmp.c
      1           #include "angle_dmp.h"
      2          
      3          //isr

   \                                 In section .bss, align 1
      4          unsigned char whoAmI = 0;
   \                     whoAmI:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
      5          unsigned char gyo_XH = 0;
   \                     gyo_XH:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
      6          unsigned char gyo_XL = 0;
   \                     gyo_XL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
      7          unsigned char gyo_YH = 0;
   \                     gyo_YH:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
      8          unsigned char gyo_YL = 0;
   \                     gyo_YL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
      9          unsigned char gyo_ZH = 0;
   \                     gyo_ZH:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     10          unsigned char gyo_ZL = 0;
   \                     gyo_ZL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     11          unsigned char acc_XH = 0;
   \                     acc_XH:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     12          unsigned char acc_XL = 0;
   \                     acc_XL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     13          unsigned char acc_YH = 0;
   \                     acc_YH:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     14          unsigned char acc_YL = 0;
   \                     acc_YL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     15          unsigned char acc_ZH = 0;
   \                     acc_ZH:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     16          unsigned char acc_ZL = 0;
   \                     acc_ZL:
   \   00000000                      DS8 1
     17          

   \                                 In section .bss, align 2
     18          unsigned short gyo_X = 0;
   \                     gyo_X:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     19          unsigned short gyo_Y = 0;
   \                     gyo_Y:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     20          unsigned short gyo_Z = 0;
   \                     gyo_Z:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     21          unsigned short acc_X = 0;
   \                     acc_X:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     22          unsigned short acc_Y = 0;
   \                     acc_Y:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     23          unsigned short acc_Z = 0;
   \                     acc_Z:
   \   00000000                      DS8 2
     24          
     25          

   \                                 In section .bss, align 2
     26          short mag_X = 0;
   \                     mag_X:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     27          short mag_Y = 0;
   \                     mag_Y:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     28          short mag_Z = 0;
   \                     mag_Z:
   \   00000000                      DS8 2
     29          
     30          #define q30  1073741824.0f

   \                                 In section .data, align 4
     31          float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
   \                     q0:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .bss, align 4
   \                     q1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     q2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     q3:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     32          unsigned long sensor_timestamp;
   \                     sensor_timestamp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     33          short gyro[3], accel[3], sensors;
   \                     gyro:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
   \                     accel:
   \   00000000                      DS8 8

   \                                 In section .bss, align 2
   \                     sensors:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     34          unsigned char more;
   \                     more:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     35          long quat[4];
   \                     quat:
   \   00000000                      DS8 16
     36          

   \                                 In section .bss, align 1
     37          uint8 device_id;
   \                     device_id:
   \   00000000                      DS8 1
     38          
     39          /* Data requested by client. */
     40          #define PRINT_ACCEL     (0x01)
     41          #define PRINT_GYRO      (0x02)
     42          #define PRINT_QUAT      (0x04)
     43          
     44          #define ACCEL_ON        (0x01)
     45          #define GYRO_ON         (0x02)
     46          
     47          #define MOTION          (0)
     48          #define NO_MOTION       (1)
     49          
     50          /* Starting sampling rate. */
     51          #define DEFAULT_MPU_HZ  (100)
     52          
     53          
     54          struct rx_s {
     55              unsigned char header[3];
     56              unsigned char cmd;
     57          };
     58          
     59          struct hal_s {
     60              unsigned char sensors;
     61              unsigned char dmp_on;
     62              unsigned char wait_for_tap;
     63              volatile unsigned char new_gyro;
     64              unsigned short report;
     65              unsigned short dmp_features;
     66              unsigned char motion_int_mode;
     67              struct rx_s rx;
     68          };

   \                                 In section .bss, align 4
     69          static struct hal_s hal = {0};
   \                     hal:
   \   00000000                      DS8 16
     70          
     71          /* The sensors can be mounted onto the board in any orientation. The mounting
     72           * matrix seen below tells the MPL how to rotate the raw data from thei
     73           * driver(s).
     74           * TODO: The following matrices refer to the configuration on an internal test
     75           * board at Invensense. If needed, please modify the matrices to match the
     76           * chip-to-body matrix for your particular set up.
     77           */

   \                                 In section .data, align 4
     78          static signed char gyro_orientation[9] = {-1,  0,  0,
   \                     gyro_orientation:
   \   00000000   0xFF 0x00          DC8 -1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0
   \              0x00 0x00    
   \              0xFF 0x00    
   \              0x00 0x00    
   \              0x01 0x00    
   \              0x00 0x00    
     79                                                     0, -1,  0,
     80                                                     0,  0,  1};
     81          
     82          enum packet_type_e {
     83              PACKET_TYPE_ACCEL,
     84              PACKET_TYPE_GYRO,
     85              PACKET_TYPE_QUAT,
     86              PACKET_TYPE_TAP,
     87              PACKET_TYPE_ANDROID_ORIENT,
     88              PACKET_TYPE_PEDO,
     89              PACKET_TYPE_MISC
     90          };
     91          
     92          
     93          /* Send data to the Python client application.
     94           * Data is formatted as follows:
     95           * packet[0]    = $
     96           * packet[1]    = packet type (see packet_type_e)
     97           * packet[2+]   = data
     98           */

   \                                 In section .text, align 2, keep-with-next
     99          void send_packet(char packet_type, void *data) {
   \                     send_packet: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    100              #define MAX_BUF_LENGTH  (18)
    101              char buf[MAX_BUF_LENGTH], length;
    102          
    103              memset(buf, 0, MAX_BUF_LENGTH);
   \   00000008   0x2212             MOVS     R2,#+18
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       memset
    104              buf[0] = '$';
   \   00000012   0x2024             MOVS     R0,#+36
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    105              buf[1] = packet_type;
   \   00000018   0xF88D 0x5001      STRB     R5,[SP, #+1]
    106          
    107              if (packet_type == PACKET_TYPE_ACCEL || packet_type == PACKET_TYPE_GYRO) {
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD002             BEQ.N    ??send_packet_0
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD119             BNE.N    ??send_packet_1
    108                  short *sdata = (short*)data;
    109                  buf[2] = (char)(sdata[0] >> 8);
   \                     ??send_packet_0: (+1)
   \   00000028   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   0000002C   0x1200             ASRS     R0,R0,#+8
   \   0000002E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    110                  buf[3] = (char)sdata[0];
   \   00000032   0x8820             LDRH     R0,[R4, #+0]
   \   00000034   0xF88D 0x0003      STRB     R0,[SP, #+3]
    111                  buf[4] = (char)(sdata[1] >> 8);
   \   00000038   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   0000003C   0x1200             ASRS     R0,R0,#+8
   \   0000003E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    112                  buf[5] = (char)sdata[1];
   \   00000042   0x8860             LDRH     R0,[R4, #+2]
   \   00000044   0xF88D 0x0005      STRB     R0,[SP, #+5]
    113                  buf[6] = (char)(sdata[2] >> 8);
   \   00000048   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   0000004C   0x1200             ASRS     R0,R0,#+8
   \   0000004E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    114                  buf[7] = (char)sdata[2];
   \   00000052   0x88A0             LDRH     R0,[R4, #+4]
   \   00000054   0xF88D 0x0007      STRB     R0,[SP, #+7]
    115                  length = 8;
   \   00000058   0x2008             MOVS     R0,#+8
   \   0000005A   0xE086             B.N      ??send_packet_2
    116              } else if (packet_type == PACKET_TYPE_QUAT) {
   \                     ??send_packet_1: (+1)
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D02             CMP      R5,#+2
   \   00000060   0xD13D             BNE.N    ??send_packet_3
    117                  long *ldata = (long*)data;
    118                  buf[2] = (char)(ldata[0] >> 24);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x1600             ASRS     R0,R0,#+24
   \   00000066   0xF88D 0x0002      STRB     R0,[SP, #+2]
    119                  buf[3] = (char)(ldata[0] >> 16);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x1400             ASRS     R0,R0,#+16
   \   0000006E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    120                  buf[4] = (char)(ldata[0] >> 8);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x1200             ASRS     R0,R0,#+8
   \   00000076   0xF88D 0x0004      STRB     R0,[SP, #+4]
    121                  buf[5] = (char)ldata[0];
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    122                  buf[6] = (char)(ldata[1] >> 24);
   \   00000080   0x6860             LDR      R0,[R4, #+4]
   \   00000082   0x1600             ASRS     R0,R0,#+24
   \   00000084   0xF88D 0x0006      STRB     R0,[SP, #+6]
    123                  buf[7] = (char)(ldata[1] >> 16);
   \   00000088   0x6860             LDR      R0,[R4, #+4]
   \   0000008A   0x1400             ASRS     R0,R0,#+16
   \   0000008C   0xF88D 0x0007      STRB     R0,[SP, #+7]
    124                  buf[8] = (char)(ldata[1] >> 8);
   \   00000090   0x6860             LDR      R0,[R4, #+4]
   \   00000092   0x1200             ASRS     R0,R0,#+8
   \   00000094   0xF88D 0x0008      STRB     R0,[SP, #+8]
    125                  buf[9] = (char)ldata[1];
   \   00000098   0x6860             LDR      R0,[R4, #+4]
   \   0000009A   0xF88D 0x0009      STRB     R0,[SP, #+9]
    126                  buf[10] = (char)(ldata[2] >> 24);
   \   0000009E   0x68A0             LDR      R0,[R4, #+8]
   \   000000A0   0x1600             ASRS     R0,R0,#+24
   \   000000A2   0xF88D 0x000A      STRB     R0,[SP, #+10]
    127                  buf[11] = (char)(ldata[2] >> 16);
   \   000000A6   0x68A0             LDR      R0,[R4, #+8]
   \   000000A8   0x1400             ASRS     R0,R0,#+16
   \   000000AA   0xF88D 0x000B      STRB     R0,[SP, #+11]
    128                  buf[12] = (char)(ldata[2] >> 8);
   \   000000AE   0x68A0             LDR      R0,[R4, #+8]
   \   000000B0   0x1200             ASRS     R0,R0,#+8
   \   000000B2   0xF88D 0x000C      STRB     R0,[SP, #+12]
    129                  buf[13] = (char)ldata[2];
   \   000000B6   0x68A0             LDR      R0,[R4, #+8]
   \   000000B8   0xF88D 0x000D      STRB     R0,[SP, #+13]
    130                  buf[14] = (char)(ldata[3] >> 24);
   \   000000BC   0x68E0             LDR      R0,[R4, #+12]
   \   000000BE   0x1600             ASRS     R0,R0,#+24
   \   000000C0   0xF88D 0x000E      STRB     R0,[SP, #+14]
    131                  buf[15] = (char)(ldata[3] >> 16);
   \   000000C4   0x68E0             LDR      R0,[R4, #+12]
   \   000000C6   0x1400             ASRS     R0,R0,#+16
   \   000000C8   0xF88D 0x000F      STRB     R0,[SP, #+15]
    132                  buf[16] = (char)(ldata[3] >> 8);
   \   000000CC   0x68E0             LDR      R0,[R4, #+12]
   \   000000CE   0x1200             ASRS     R0,R0,#+8
   \   000000D0   0xF88D 0x0010      STRB     R0,[SP, #+16]
    133                  buf[17] = (char)ldata[3];
   \   000000D4   0x68E0             LDR      R0,[R4, #+12]
   \   000000D6   0xF88D 0x0011      STRB     R0,[SP, #+17]
    134                  length = 18;
   \   000000DA   0x2012             MOVS     R0,#+18
   \   000000DC   0xE045             B.N      ??send_packet_2
    135              } else if (packet_type == PACKET_TYPE_TAP) {
   \                     ??send_packet_3: (+1)
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0x2D03             CMP      R5,#+3
   \   000000E2   0xD107             BNE.N    ??send_packet_4
    136                  buf[2] = ((char*)data)[0];
   \   000000E4   0x7820             LDRB     R0,[R4, #+0]
   \   000000E6   0xF88D 0x0002      STRB     R0,[SP, #+2]
    137                  buf[3] = ((char*)data)[1];
   \   000000EA   0x7860             LDRB     R0,[R4, #+1]
   \   000000EC   0xF88D 0x0003      STRB     R0,[SP, #+3]
    138                  length = 4;
   \   000000F0   0x2004             MOVS     R0,#+4
   \   000000F2   0xE03A             B.N      ??send_packet_2
    139              } else if (packet_type == PACKET_TYPE_ANDROID_ORIENT) {
   \                     ??send_packet_4: (+1)
   \   000000F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F6   0x2D04             CMP      R5,#+4
   \   000000F8   0xD104             BNE.N    ??send_packet_5
    140                  buf[2] = ((char*)data)[0];
   \   000000FA   0x7820             LDRB     R0,[R4, #+0]
   \   000000FC   0xF88D 0x0002      STRB     R0,[SP, #+2]
    141                  length = 3;
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0xE032             B.N      ??send_packet_2
    142              } else if (packet_type == PACKET_TYPE_PEDO) {
   \                     ??send_packet_5: (+1)
   \   00000104   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000106   0x2D05             CMP      R5,#+5
   \   00000108   0xD11F             BNE.N    ??send_packet_6
    143                  long *ldata = (long*)data;
    144                  buf[2] = (char)(ldata[0] >> 24);
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x1600             ASRS     R0,R0,#+24
   \   0000010E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    145                  buf[3] = (char)(ldata[0] >> 16);
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x1400             ASRS     R0,R0,#+16
   \   00000116   0xF88D 0x0003      STRB     R0,[SP, #+3]
    146                  buf[4] = (char)(ldata[0] >> 8);
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x1200             ASRS     R0,R0,#+8
   \   0000011E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    147                  buf[5] = (char)ldata[0];
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xF88D 0x0005      STRB     R0,[SP, #+5]
    148                  buf[6] = (char)(ldata[1] >> 24);
   \   00000128   0x6860             LDR      R0,[R4, #+4]
   \   0000012A   0x1600             ASRS     R0,R0,#+24
   \   0000012C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    149                  buf[7] = (char)(ldata[1] >> 16);
   \   00000130   0x6860             LDR      R0,[R4, #+4]
   \   00000132   0x1400             ASRS     R0,R0,#+16
   \   00000134   0xF88D 0x0007      STRB     R0,[SP, #+7]
    150                  buf[8] = (char)(ldata[1] >> 8);
   \   00000138   0x6860             LDR      R0,[R4, #+4]
   \   0000013A   0x1200             ASRS     R0,R0,#+8
   \   0000013C   0xF88D 0x0008      STRB     R0,[SP, #+8]
    151                  buf[9] = (char)ldata[1];
   \   00000140   0x6860             LDR      R0,[R4, #+4]
   \   00000142   0xF88D 0x0009      STRB     R0,[SP, #+9]
    152                  length = 10;
   \   00000146   0x200A             MOVS     R0,#+10
   \   00000148   0xE00F             B.N      ??send_packet_2
    153              } else if (packet_type == PACKET_TYPE_MISC) {
   \                     ??send_packet_6: (+1)
   \   0000014A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014C   0x2D06             CMP      R5,#+6
   \   0000014E   0xD10C             BNE.N    ??send_packet_2
    154                  buf[2] = ((char*)data)[0];
   \   00000150   0x7820             LDRB     R0,[R4, #+0]
   \   00000152   0xF88D 0x0002      STRB     R0,[SP, #+2]
    155                  buf[3] = ((char*)data)[1];
   \   00000156   0x7860             LDRB     R0,[R4, #+1]
   \   00000158   0xF88D 0x0003      STRB     R0,[SP, #+3]
    156                  buf[4] = ((char*)data)[2];
   \   0000015C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000015E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    157                  buf[5] = ((char*)data)[3];
   \   00000162   0x78E0             LDRB     R0,[R4, #+3]
   \   00000164   0xF88D 0x0005      STRB     R0,[SP, #+5]
    158                  length = 6;
   \   00000168   0x2006             MOVS     R0,#+6
    159              }
    160             // UART_send_str((unsigned char *)buf);
    161          }
   \                     ??send_packet_2: (+1)
   \   0000016A   0xB005             ADD      SP,SP,#+20
   \   0000016C   0xBD30             POP      {R4,R5,PC}       ;; return
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void send_client(void)
    164          {
   \                     send_client: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    165            send_packet(PACKET_TYPE_QUAT, quat);
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       send_packet
    166          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    167          
    168          /* These next two functions converts the orientation matrix (see
    169           * gyro_orientation) to a scalar representation for use by the DMP.
    170           * NOTE: These functions are borrowed from Invensense's MPL.
    171           */

   \                                 In section .text, align 2, keep-with-next
    172          static inline unsigned short inv_row_2_scale(const signed char *row) {
    173              unsigned short b;
    174          
    175              if (row[0] > 0)
   \                     inv_row_2_scale: (+1)
   \   00000000   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xDB01             BLT.N    ??inv_row_2_scale_0
    176                  b = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE01E             B.N      ??inv_row_2_scale_1
    177              else if (row[0] < 0)
   \                     ??inv_row_2_scale_0: (+1)
   \   0000000C   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD501             BPL.N    ??inv_row_2_scale_2
    178                  b = 4;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xE018             B.N      ??inv_row_2_scale_1
    179              else if (row[1] > 0)
   \                     ??inv_row_2_scale_2: (+1)
   \   00000018   0xF990 0x1001      LDRSB    R1,[R0, #+1]
   \   0000001C   0x2901             CMP      R1,#+1
   \   0000001E   0xDB01             BLT.N    ??inv_row_2_scale_3
    180                  b = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE012             B.N      ??inv_row_2_scale_1
    181              else if (row[1] < 0)
   \                     ??inv_row_2_scale_3: (+1)
   \   00000024   0xF990 0x1001      LDRSB    R1,[R0, #+1]
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD501             BPL.N    ??inv_row_2_scale_4
    182                  b = 5;
   \   0000002C   0x2005             MOVS     R0,#+5
   \   0000002E   0xE00C             B.N      ??inv_row_2_scale_1
    183              else if (row[2] > 0)
   \                     ??inv_row_2_scale_4: (+1)
   \   00000030   0xF990 0x1002      LDRSB    R1,[R0, #+2]
   \   00000034   0x2901             CMP      R1,#+1
   \   00000036   0xDB01             BLT.N    ??inv_row_2_scale_5
    184                  b = 2;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE006             B.N      ??inv_row_2_scale_1
    185              else if (row[2] < 0)
   \                     ??inv_row_2_scale_5: (+1)
   \   0000003C   0xF990 0x0002      LDRSB    R0,[R0, #+2]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD501             BPL.N    ??inv_row_2_scale_6
    186                  b = 6;
   \   00000044   0x2006             MOVS     R0,#+6
   \   00000046   0xE000             B.N      ??inv_row_2_scale_1
    187              else
    188                  b = 7; // error
   \                     ??inv_row_2_scale_6: (+1)
   \   00000048   0x2007             MOVS     R0,#+7
    189              return b;
   \                     ??inv_row_2_scale_1: (+1)
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x4770             BX       LR               ;; return
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          static inline unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx) {
   \                     inv_orientation_matrix_to_scalar: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    193              unsigned short scalar;
    194          
    195              /*
    196                 XYZ  010_001_000 Identity Matrix
    197                 XZY  001_010_000
    198                 YXZ  010_000_001
    199                 YZX  000_010_001
    200                 ZXY  001_000_010
    201                 ZYX  000_001_010
    202               */
    203          
    204              scalar = inv_row_2_scale(mtx);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       inv_row_2_scale
   \   0000000A   0x0005             MOVS     R5,R0
    205              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   0000000C   0x1CE0             ADDS     R0,R4,#+3
   \   0000000E   0x.... 0x....      BL       inv_row_2_scale
   \   00000012   0xEA55 0x05C0      ORRS     R5,R5,R0, LSL #+3
    206              scalar |= inv_row_2_scale(mtx + 6) << 6;
   \   00000016   0x1DA0             ADDS     R0,R4,#+6
   \   00000018   0x.... 0x....      BL       inv_row_2_scale
   \   0000001C   0xEA55 0x1580      ORRS     R5,R5,R0, LSL #+6
    207          
    208              return scalar;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    209          }
    210          
    211          /* Handle sensor on/off combinations. */
    212          static void setup_gyro(void) {
    213              unsigned char mask = 0;
    214              if (hal.sensors & ACCEL_ON)
    215                  mask |= INV_XYZ_ACCEL;
    216              if (hal.sensors & GYRO_ON)
    217                  mask |= INV_XYZ_GYRO;
    218              /* If you need a power transition, this function should be called with a
    219               * mask of the sensors still enabled. The driver turns off any sensors
    220               * excluded from this mask.
    221               */
    222              mpu_set_sensors(mask);
    223              if (!hal.dmp_on)
    224                  mpu_configure_fifo(mask);
    225          }
    226          

   \                                 In section .text, align 2, keep-with-next
    227          static void tap_cb(unsigned char direction, unsigned char count) {
   \                     tap_cb: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    228              char data[2];
    229              data[0] = (char)direction;
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
    230              data[1] = (char)count;
   \   00000006   0xF88D 0x1001      STRB     R1,[SP, #+1]
    231              send_packet(PACKET_TYPE_TAP, data);
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x.... 0x....      BL       send_packet
    232          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    233          

   \                                 In section .text, align 2, keep-with-next
    234          static void android_orient_cb(unsigned char orientation) {
   \                     android_orient_cb: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    235              send_packet(PACKET_TYPE_ANDROID_ORIENT, &orientation);
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       send_packet
    236          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    237          
    238          static inline void run_self_test(void) {
    239              int result;
    240              char test_packet[4] = {0};
    241              long gyro[3], accel[3];
    242          
    243              result = mpu_run_self_test(gyro, accel);
    244              if (result == 0x7) {
    245                  /* Test passed. We can trust the gyro data here, so let's push it down
    246                   * to the DMP.
    247                   */
    248                  float sens;
    249                  unsigned short accel_sens;
    250                  mpu_get_gyro_sens(&sens);
    251                  gyro[0] = (long) (gyro[0] * sens);
    252                  gyro[1] = (long) (gyro[1] * sens);
    253                  gyro[2] = (long) (gyro[2] * sens);
    254                  dmp_set_gyro_bias(gyro);
    255                  mpu_get_accel_sens(&accel_sens);
    256                  accel[0] *= accel_sens;
    257                  accel[1] *= accel_sens;
    258                  accel[2] *= accel_sens;
    259                  dmp_set_accel_bias(accel);
    260              }
    261          
    262              /* Report results. */
    263              test_packet[0] = 't';
    264              test_packet[1] = result;
    265              send_packet(PACKET_TYPE_MISC, test_packet);
    266          }
    267          

   \                                 In section .text, align 2, keep-with-next
    268          static void gyro_data_ready_cb(void) {
    269              hal.new_gyro = 1;
   \                     gyro_data_ready_cb: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_1
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x70C1             STRB     R1,[R0, #+3]
    270          }
   \   00000006   0x4770             BX       LR               ;; return
    271          

   \                                 In section .text, align 2, keep-with-next
    272          void set_dmp (void){
   \                     set_dmp: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    273            //debug_mode1(gyro_X);
    274            
    275              int result;
    276              unsigned char accel_fsr;
    277              unsigned short gyro_rate, gyro_fsr;
    278              struct int_param_s int_param;
    279           
    280              
    281          //#ifdef DELUG_USE_TERMINAL
    282            // UART_send_str(">>> Hardware Init Successful!\n");
    283          //#endif
    284          
    285              /* Set up gyro.
    286               * Every function preceded by mpu_ is a driver function and can be found
    287               * in inv_mpu.h.
    288               */
    289              int_param.cb = gyro_data_ready_cb;
   \   00000002   0x....             LDR.N    R0,??DataTable4_2
   \   00000004   0x9001             STR      R0,[SP, #+4]
    290              int_param.active_low = 1;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF88D 0x000B      STRB     R0,[SP, #+11]
    291              result = mpu_init(&int_param);
   \   0000000C   0xA801             ADD      R0,SP,#+4
   \   0000000E   0x.... 0x....      BL       mpu_init
   \   00000012   0x0004             MOVS     R4,R0
    292          //#ifdef DELUG_USE_TERMINAL
    293             // if (0 == result)
    294              //    UART_send_str(">>> Mpu9150  Init Successful!\n");
    295          //#endif
    296          
    297              /* If you're not using an MPU9150 AND you're not using DMP features, this
    298               * function will place all slaves on the primary bus.
    299               * mpu_set_bypass(1);
    300               */
    301          
    302              /* Get/set hardware configuration. Start gyro. */
    303              /* Wake up all sensors. */
    304              mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL);
   \   00000014   0x2078             MOVS     R0,#+120
   \   00000016   0x.... 0x....      BL       mpu_set_sensors
    305              /* Push both gyro and accel data into the FIFO. */
    306              mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);
   \   0000001A   0x2078             MOVS     R0,#+120
   \   0000001C   0x.... 0x....      BL       mpu_configure_fifo
    307              mpu_set_sample_rate(DEFAULT_MPU_HZ);
   \   00000020   0x2064             MOVS     R0,#+100
   \   00000022   0x.... 0x....      BL       mpu_set_sample_rate
    308              /* Read back configuration in case it was set improperly. */
    309              mpu_get_sample_rate(&gyro_rate);
   \   00000026   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000002A   0x.... 0x....      BL       mpu_get_sample_rate
    310              mpu_get_gyro_fsr(&gyro_fsr);
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       mpu_get_gyro_fsr
    311              mpu_get_accel_fsr(&accel_fsr);
   \   00000034   0xA803             ADD      R0,SP,#+12
   \   00000036   0x.... 0x....      BL       mpu_get_accel_fsr
    312          
    313              /* Initialize HAL state variables. */
    314              memset(&hal, 0, sizeof (hal));
   \   0000003A   0x220E             MOVS     R2,#+14
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x....             LDR.N    R0,??DataTable4_1
   \   00000040   0x.... 0x....      BL       memset
    315              hal.sensors = ACCEL_ON | GYRO_ON;
   \   00000044   0x....             LDR.N    R0,??DataTable4_1
   \   00000046   0x2103             MOVS     R1,#+3
   \   00000048   0x7001             STRB     R1,[R0, #+0]
    316              hal.report = PRINT_QUAT;
   \   0000004A   0x....             LDR.N    R0,??DataTable4_1
   \   0000004C   0x2104             MOVS     R1,#+4
   \   0000004E   0x8081             STRH     R1,[R0, #+4]
    317          
    318              /* To initialize the DMP:
    319               * 1. Call dmp_load_motion_driver_firmware(). This pushes the DMP image in
    320               *    inv_mpu_dmp_motion_driver.h into the MPU memory.
    321               * 2. Push the gyro and accel orientation matrix to the DMP.
    322               * 3. Register gesture callbacks. Don't worry, these callbacks won't be
    323               *    executed unless the corresponding feature is enabled.
    324               * 4. Call dmp_enable_feature(mask) to enable different features.
    325               * 5. Call dmp_set_fifo_rate(freq) to select a DMP output rate.
    326               * 6. Call any feature-specific control functions.
    327               *
    328               * To enable the DMP, just call mpu_set_dmp_state(1). This function can
    329               * be called repeatedly to enable and disable the DMP at runtime.
    330               *
    331               * The following is a short summary of the features supported in the DMP
    332               * image provided in inv_mpu_dmp_motion_driver.c:
    333               * DMP_FEATURE_LP_QUAT: Generate a gyro-only quaternion on the DMP at
    334               * 200Hz. Integrating the gyro data at higher rates reduces numerical
    335               * errors (compared to integration on the MCU at a lower sampling rate).
    336               * DMP_FEATURE_6X_LP_QUAT: Generate a gyro/accel quaternion on the DMP at
    337               * 200Hz. Cannot be used in combination with DMP_FEATURE_LP_QUAT.
    338               * DMP_FEATURE_TAP: Detect taps along the X, Y, and Z axes.
    339               * DMP_FEATURE_ANDROID_ORIENT: Google's screen rotation algorithm. Triggers
    340               * an event at the four orientations where the screen should rotate.
    341               * DMP_FEATURE_GYRO_CAL: Calibrates the gyro data after eight seconds of
    342               * no motion.
    343               * DMP_FEATURE_SEND_RAW_ACCEL: Add raw accelerometer data to the FIFO.
    344               * DMP_FEATURE_SEND_RAW_GYRO: Add raw gyro data to the FIFO.
    345               * DMP_FEATURE_SEND_CAL_GYRO: Add calibrated gyro data to the FIFO. Cannot
    346               * be used in combination with DMP_FEATURE_SEND_RAW_GYRO.
    347               */
    348              result = dmp_load_motion_driver_firmware();
   \   00000050   0x.... 0x....      BL       dmp_load_motion_driver_firmware
   \   00000054   0x0004             MOVS     R4,R0
    349          //#ifdef DELUG_USE_TERMINAL
    350           //   if (0 == result)
    351            //      UART_send_str(">>> Load Firmware Successful!\n");
    352          //#endif
    353              dmp_set_orientation(
    354                      inv_orientation_matrix_to_scalar(gyro_orientation));
   \   00000056   0x....             LDR.N    R0,??DataTable4_3
   \   00000058   0x.... 0x....      BL       inv_orientation_matrix_to_scalar
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x.... 0x....      BL       dmp_set_orientation
    355              dmp_register_tap_cb(tap_cb);
   \   00000062   0x....             LDR.N    R0,??DataTable4_4
   \   00000064   0x.... 0x....      BL       dmp_register_tap_cb
    356              dmp_register_android_orient_cb(android_orient_cb);
   \   00000068   0x....             LDR.N    R0,??DataTable4_5
   \   0000006A   0x.... 0x....      BL       dmp_register_android_orient_cb
    357              hal.dmp_features = DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_TAP |
    358                      DMP_FEATURE_ANDROID_ORIENT | DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_CAL_GYRO |
    359                      DMP_FEATURE_GYRO_CAL;
   \   0000006E   0x....             LDR.N    R0,??DataTable4_1
   \   00000070   0xF240 0x1173      MOVW     R1,#+371
   \   00000074   0x80C1             STRH     R1,[R0, #+6]
    360              dmp_enable_feature(hal.dmp_features);
   \   00000076   0x....             LDR.N    R0,??DataTable4_1
   \   00000078   0x88C0             LDRH     R0,[R0, #+6]
   \   0000007A   0x.... 0x....      BL       dmp_enable_feature
    361              dmp_set_fifo_rate(DEFAULT_MPU_HZ);
   \   0000007E   0x2064             MOVS     R0,#+100
   \   00000080   0x.... 0x....      BL       dmp_set_fifo_rate
    362              mpu_set_dmp_state(1);
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       mpu_set_dmp_state
    363              hal.dmp_on = 1;
   \   0000008A   0x....             LDR.N    R0,??DataTable4_1
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x7041             STRB     R1,[R0, #+1]
    364              hal.new_gyro = 1;
   \   00000090   0x....             LDR.N    R0,??DataTable4_1
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x70C1             STRB     R1,[R0, #+3]
    365          //    run_self_test();
    366          }
   \   00000096   0xBD1F             POP      {R0-R4,PC}       ;; return
    367          

   \                                 In section .text, align 2, keep-with-next
    368          void get_angle(void){
   \                     get_angle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    369           //hal.new_gyro = 1;
    370                  // 未使能传感器或未收到新数据
    371                 // if (!hal.sensors || !hal.new_gyro) {
    372                      // 可以在此处休眠，以降低功耗
    373                  //    continue;
    374                  //}
    375                  // 传感器数据准备好并且打开DMP功能
    376                  if (hal.new_gyro && hal.dmp_on) 
   \   00000004   0x....             LDR.N    R0,??DataTable4_1
   \   00000006   0x78C0             LDRB     R0,[R0, #+3]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD065             BEQ.N    ??get_angle_0
   \   0000000C   0x....             LDR.N    R0,??DataTable4_1
   \   0000000E   0x7840             LDRB     R0,[R0, #+1]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD061             BEQ.N    ??get_angle_0
    377                  {
    378                      
    379                      //long quat[4];
    380                      /* This function gets new data from the FIFO when the DMP is in
    381                       * use. The FIFO can contain any combination of gyro, accel,
    382                       * quaternion, and gesture data. The sensors parameter tells the
    383                       * caller which data fields were actually populated with new data.
    384                       * For example, if sensors == (INV_XYZ_GYRO | INV_WXYZ_QUAT), then
    385                       * the FIFO isn't being filled with accel data.
    386                       * The driver parses the gesture data to determine if a gesture
    387                       * event has occurred; on an event, the application will be notified
    388                       * via a callback (assuming that a callback function was properly
    389                       * registered). The more parameter is non-zero if there are
    390                       * leftover packets in the FIFO.
    391                       */
    392                      dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors, &more);
   \   00000014   0x....             LDR.N    R0,??DataTable4_6
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x....             LDR.N    R0,??DataTable4_7
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x....             LDR.N    R3,??DataTable4_8
   \   0000001E   0x....             LDR.N    R2,??DataTable4
   \   00000020   0x....             LDR.N    R1,??DataTable4_9
   \   00000022   0x....             LDR.N    R0,??DataTable4_10
   \   00000024   0x.... 0x....      BL       dmp_read_fifo
    393                      //if (!more)
    394                      //{
    395                        //hal.new_gyro = 0;
    396                      //}
    397                      /* Gyro and accel  are written to the FIFO by the DMP in chip
    398                       * frame and hardware units. This behavior is convenient because it
    399                       * keeps the gyro and accel outputs of dmp_read_fifo and
    400                       * mpu_read_fifo consistent.
    401                       */
    402                      //if (sensors & INV_XYZ_GYRO && hal.report & PRINT_GYRO)
    403                      //send_packet(PACKET_TYPE_GYRO, gyro);
    404                      //if (sensors & INV_XYZ_ACCEL && hal.report & PRINT_ACCEL)
    405                      //send_packet(PACKET_TYPE_ACCEL, accel);
    406                      /* Unlike gyro and accel, quaternions are written to the FIFO in
    407                       * the body frame, q30. The orientation is set by the scalar passed
    408                       * to dmp_set_orientation during initialization.
    409                       */
    410                      if (sensors & INV_WXYZ_QUAT && hal.report & PRINT_QUAT)
   \   00000028   0x....             LDR.N    R0,??DataTable4_7
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x0680             LSLS     R0,R0,#+26
   \   0000002E   0xF140 0x8080      BPL.W    ??get_angle_1
   \   00000032   0x....             LDR.N    R0,??DataTable4_1
   \   00000034   0x7900             LDRB     R0,[R0, #+4]
   \   00000036   0x0740             LSLS     R0,R0,#+29
   \   00000038   0xD57B             BPL.N    ??get_angle_1
    411                      {
    412                         //ss++;  
    413                        
    414                        q0=(float)quat[0] / q30;
   \   0000003A   0x....             LDR.N    R0,??DataTable4
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       __aeabi_i2f
   \   00000042   0xF05F 0x419D      MOVS     R1,#+1317011456
   \   00000046   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004A   0x....             LDR.N    R1,??DataTable4_11
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    415                        q1=(float)quat[1] / q30;
   \   0000004E   0x....             LDR.N    R0,??DataTable4
   \   00000050   0x6840             LDR      R0,[R0, #+4]
   \   00000052   0x.... 0x....      BL       __aeabi_i2f
   \   00000056   0xF05F 0x419D      MOVS     R1,#+1317011456
   \   0000005A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000005E   0x....             LDR.N    R1,??DataTable4_12
   \   00000060   0x6008             STR      R0,[R1, #+0]
    416                        q2=(float)quat[2] / q30;
   \   00000062   0x....             LDR.N    R0,??DataTable4
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0x.... 0x....      BL       __aeabi_i2f
   \   0000006A   0xF05F 0x419D      MOVS     R1,#+1317011456
   \   0000006E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000072   0x....             LDR.N    R1,??DataTable4_13
   \   00000074   0x6008             STR      R0,[R1, #+0]
    417                        q3=(float)quat[3] / q30;
   \   00000076   0x....             LDR.N    R0,??DataTable4
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0x.... 0x....      BL       __aeabi_i2f
   \   0000007E   0xF05F 0x419D      MOVS     R1,#+1317011456
   \   00000082   0x.... 0x....      BL       __aeabi_fdiv
   \   00000086   0x....             LDR.N    R1,??DataTable4_14
   \   00000088   0x6008             STR      R0,[R1, #+0]
    418                        
    419                        Pitch  = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3; // Pitch
   \   0000008A   0x....             LDR.N    R0,??DataTable4_12
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF05F 0x4140      MOVS     R1,#-1073741824
   \   00000092   0x.... 0x....      BL       __aeabi_fmul
   \   00000096   0x....             LDR.N    R1,??DataTable4_14
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0x.... 0x....      BL       __aeabi_fmul
   \   0000009E   0x0004             MOVS     R4,R0
   \   000000A0   0x....             LDR.N    R0,??DataTable4_11
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000000A8   0x.... 0x....      BL       __aeabi_fmul
   \   000000AC   0x....             LDR.N    R1,??DataTable4_13
   \   000000AE   0x6809             LDR      R1,[R1, #+0]
   \   000000B0   0x.... 0x....      BL       __aeabi_fmul
   \   000000B4   0x0001             MOVS     R1,R0
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       __aeabi_fadd
   \   000000BC   0x.... 0x....      BL       __aeabi_f2d
   \   000000C0   0x.... 0x....      BL       asin
   \   000000C4   0xF05F 0x3266      MOVS     R2,#+1717986918
   \   000000C8   0x....             LDR.N    R3,??DataTable4_15  ;; 0x404ca666
   \   000000CA   0x.... 0x....      BL       __aeabi_dmul
   \   000000CE   0x.... 0x....      BL       __aeabi_d2f
   \   000000D2   0x....             LDR.N    R1,??DataTable4_16
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   \   000000D6   0xE02C             B.N      ??get_angle_1
    420                        //Roll = atan((2 * q2 * q3 + 2 * q0 * q1)/ (q0*q0-q1*q1-q2*q2+q3*q3))* 57.3; // Roll
    421                        //Yaw = atan(2*(q1*q2 + q0*q3)/(q0*q0+q1*q1-q2*q2-q3*q3)) * 57.3; //Yaw
    422                        
    423                        //float r_a = cos(Pitch*0.5f)*cos(Roll*0.5f)*cos(Yaw*0.5f) + sin(Pitch*0.5f)*sin(Roll*0.5f)*sin(Yaw*0.5f);
    424                        //float r_x = sin(Pitch*0.5f)*cos(Roll*0.5f)*cos(Yaw*0.5f) - cos(Pitch*0.5f)*sin(Roll*0.5f)*sin(Yaw*0.5f);
    425                        //float r_y = cos(Pitch*0.5f)*sin(Roll*0.5f)*cos(Yaw*0.5f) + sin(Pitch*0.5f)*cos(Roll*0.5f)*sin(Yaw*0.5f);
    426                        //float r_z = cos(Pitch*0.5f)*cos(Roll*0.5f)*sin(Yaw*0.5f) - sin(Pitch*0.5f)*sin(Roll*0.5f)*cos(Yaw*0.5f);
    427                        
    428                   
    429                        
    430          //              OutData[0]= Pitch*10;  
    431          //              OutData[1]= Roll*10;  
    432          //              OutData[2]= Yaw*10;  
    433          //              OutData[3]= 0; 
    434          //              OutPut_Data();
    435                      }
    436                  }
    437                  else if (hal.new_gyro)
   \                     ??get_angle_0: (+1)
   \   000000D8   0x....             LDR.N    R0,??DataTable4_1
   \   000000DA   0x78C0             LDRB     R0,[R0, #+3]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD028             BEQ.N    ??get_angle_1
    438                  {
    439                      short gyro[3], accel[3];
    440                      unsigned char sensors, more;
    441                      /* This function gets new data from the FIFO. The FIFO can contain
    442                       * gyro, accel, both, or neither. The sensors parameter tells the
    443                       * caller which data fields were actually populated with new data.
    444                       * For example, if sensors == INV_XYZ_GYRO, then the FIFO isn't
    445                       * being filled with accel data. The more parameter is non-zero if
    446                       * there are leftover packets in the FIFO.
    447                       */
    448                      mpu_read_fifo(gyro, accel, &sensor_timestamp, &sensors, &more);
   \   000000E0   0xF10D 0x0005      ADD      R0,SP,#+5
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0xAB01             ADD      R3,SP,#+4
   \   000000E8   0x....             LDR.N    R2,??DataTable4_8
   \   000000EA   0xA902             ADD      R1,SP,#+8
   \   000000EC   0xA804             ADD      R0,SP,#+16
   \   000000EE   0x.... 0x....      BL       mpu_read_fifo
    449                      if (!more)
   \   000000F2   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD102             BNE.N    ??get_angle_2
    450                          hal.new_gyro = 0;
   \   000000FA   0x....             LDR.N    R0,??DataTable4_1
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0x70C1             STRB     R1,[R0, #+3]
    451                      if (sensors & INV_XYZ_GYRO && hal.report & PRINT_GYRO)
   \                     ??get_angle_2: (+1)
   \   00000100   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000104   0x2170             MOVS     R1,#+112
   \   00000106   0x4208             TST      R0,R1
   \   00000108   0xD007             BEQ.N    ??get_angle_3
   \   0000010A   0x....             LDR.N    R0,??DataTable4_1
   \   0000010C   0x7900             LDRB     R0,[R0, #+4]
   \   0000010E   0x0780             LSLS     R0,R0,#+30
   \   00000110   0xD503             BPL.N    ??get_angle_3
    452                          send_packet(PACKET_TYPE_GYRO, gyro);
   \   00000112   0xA904             ADD      R1,SP,#+16
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0x.... 0x....      BL       send_packet
    453                      if (sensors & INV_XYZ_ACCEL && hal.report & PRINT_ACCEL)
   \                     ??get_angle_3: (+1)
   \   0000011A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000011E   0x0700             LSLS     R0,R0,#+28
   \   00000120   0xD507             BPL.N    ??get_angle_1
   \   00000122   0x....             LDR.N    R0,??DataTable4_1
   \   00000124   0x7900             LDRB     R0,[R0, #+4]
   \   00000126   0x07C0             LSLS     R0,R0,#+31
   \   00000128   0xD503             BPL.N    ??get_angle_1
    454                          send_packet(PACKET_TYPE_ACCEL, accel);
   \   0000012A   0xA902             ADD      R1,SP,#+8
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x.... 0x....      BL       send_packet
    455                  }
    456           
    457          }
   \                     ??get_angle_1: (+1)
   \   00000132   0xB006             ADD      SP,SP,#+24
   \   00000134   0xBD10             POP      {R4,PC}          ;; return
    458          

   \                                 In section .text, align 2, keep-with-next
    459          void get_velocity(void)
    460          {
   \                     get_velocity: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    461              //获取FTM1的正交解码计数值
    462              qd_speed_l = LPLD_FTM_GetCounter(FTM1);
   \   00000002   0x....             LDR.N    R0,??DataTable4_17  ;; 0x40039000
   \   00000004   0x.... 0x....      BL       LPLD_FTM_GetCounter
   \   00000008   0x....             LDR.N    R1,??DataTable4_18
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
    463              //清空计数器
    464              LPLD_FTM_ClearCounter(FTM1);
   \   0000000C   0x....             LDR.N    R0,??DataTable4_17  ;; 0x40039000
   \   0000000E   0x.... 0x....      BL       LPLD_FTM_ClearCounter
    465              //获取FTM1的正交解码计数值
    466              qd_speed_r = LPLD_FTM_GetCounter(FTM2);
   \   00000012   0x....             LDR.N    R0,??DataTable4_19  ;; 0x400b8000
   \   00000014   0x.... 0x....      BL       LPLD_FTM_GetCounter
   \   00000018   0x....             LDR.N    R1,??DataTable4_20
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    467              //清空计数器
    468              LPLD_FTM_ClearCounter(FTM2);
   \   0000001C   0x....             LDR.N    R0,??DataTable4_19  ;; 0x400b8000
   \   0000001E   0x.... 0x....      BL       LPLD_FTM_ClearCounter
    469          }
   \   00000022   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     quat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     hal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     gyro_data_ready_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     gyro_orientation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     tap_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     android_orient_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     more

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     sensors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     sensor_timestamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     accel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     gyro

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     q0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x........         DC32     q1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x........         DC32     q2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x........         DC32     q3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x404CA666         DC32     0x404ca666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x........         DC32     Pitch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x40039000         DC32     0x40039000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \   00000000   0x........         DC32     qd_speed_l

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_19:
   \   00000000   0x400B8000         DC32     0x400b8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_20:
   \   00000000   0x........         DC32     qd_speed_r

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   android_orient_cb
         8   -> send_packet
      32   get_angle
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
        32   -> asin
        32   -> dmp_read_fifo
        32   -> mpu_read_fifo
        32   -> send_packet
       8   get_velocity
         8   -> LPLD_FTM_ClearCounter
         8   -> LPLD_FTM_GetCounter
       0   gyro_data_ready_cb
      16   inv_orientation_matrix_to_scalar
        16   -> inv_row_2_scale
       0   inv_row_2_scale
       8   send_client
         8   -> send_packet
      32   send_packet
        32   -> memset
      24   set_dmp
        24   -> dmp_enable_feature
        24   -> dmp_load_motion_driver_firmware
        24   -> dmp_register_android_orient_cb
        24   -> dmp_register_tap_cb
        24   -> dmp_set_fifo_rate
        24   -> dmp_set_orientation
        24   -> inv_orientation_matrix_to_scalar
        24   -> memset
        24   -> mpu_configure_fifo
        24   -> mpu_get_accel_fsr
        24   -> mpu_get_gyro_fsr
        24   -> mpu_get_sample_rate
        24   -> mpu_init
        24   -> mpu_set_dmp_state
        24   -> mpu_set_sample_rate
        24   -> mpu_set_sensors
       8   tap_cb
         8   -> send_packet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_20
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  acc_X
       1  acc_XH
       1  acc_XL
       2  acc_Y
       1  acc_YH
       1  acc_YL
       2  acc_Z
       1  acc_ZH
       1  acc_ZL
       8  accel
      12  android_orient_cb
       1  device_id
     310  get_angle
      36  get_velocity
       2  gyo_X
       1  gyo_XH
       1  gyo_XL
       2  gyo_Y
       1  gyo_YH
       1  gyo_YL
       2  gyo_Z
       1  gyo_ZH
       1  gyo_ZL
       8  gyro
       8  gyro_data_ready_cb
      12  gyro_orientation
      16  hal
      38  inv_orientation_matrix_to_scalar
      78  inv_row_2_scale
       2  mag_X
       2  mag_Y
       2  mag_Z
       1  more
       4  q0
       4  q1
       4  q2
       4  q3
      16  quat
      12  send_client
     366  send_packet
       4  sensor_timestamp
       2  sensors
     152  set_dmp
      20  tap_cb
       1  whoAmI

 
    99 bytes in section .bss
    16 bytes in section .data
 1 116 bytes in section .text
 
 1 116 bytes of CODE memory
   115 bytes of DATA memory

Errors: none
Warnings: 4
