###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.70.2.6274/W32 for ARM      03/Nov/2019  15:52:03 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Buyun\Progress\memristor based control\mcu            #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\lib\LPLD\HW\iic.c               #
#    Command line =  "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\lib\LPLD\HW\iic.c" -D LPLD_K60  #
#                    -lCN "D:\Buyun\Progress\memristor based control\mcu      #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\" -lB                #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\" -o                 #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5_2\arm\INC\c\DLib_Config_Normal.h" -I                 #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\app\" -I                     #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\CPU\" -I           #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\common\" -I        #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\" -I          #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\HW\" -I       #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\DEV\" -I      #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\uCOS-II\Ports\"    #
#                    -I "D:\Buyun\Progress\memristor based control\mcu        #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\uCOS-II\Source\"   #
#                    -I "D:\Buyun\Progress\memristor based control\mcu        #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\FatFs\" -I         #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\FatFs\option\" -I  #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\common\" -I    #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\driver\" -I    #
#                    "D:\Buyun\Progress\memristor based control\mcu           #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\descriptor\"   #
#                    -I "D:\Buyun\Progress\memristor based control\mcu        #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\class\" -Ol    #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM4      #
#    List file    =  D:\Buyun\Progress\memristor based control\mcu            #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\iic.lst              #
#    Object file  =  D:\Buyun\Progress\memristor based control\mcu            #
#                    code\paper code\0.1ms control period\test                #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\Obj\iic.o                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\Buyun\Progress\memristor based control\mcu code\paper code\0.1ms control period\test code\CBY_K60_balance_DAC\lib\LPLD\HW\iic.c
      1          #include "common.h"
      2          #include "iic.h"
      3          

   \                                 In section .bss, align 1
      4          unsigned char ack;
   \                     ack:
   \   00000000                      DS8 1
      5          

   \                                 In section .text, align 2, keep-with-next
      6          void DelayUs(unsigned int us)
      7          {
      8            int ii,jj;
      9            if (us<1) us=1;
   \                     DelayUs: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE.N    ??DelayUs_0
   \   00000004   0x2001             MOVS     R0,#+1
     10            for(ii=0;ii<us;ii++)
   \                     ??DelayUs_0: (+1)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xE003             B.N      ??DelayUs_1
     11              for(jj=0;jj<13;jj++);   //50MHz--1us
   \                     ??DelayUs_2: (+1)
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \                     ??DelayUs_3: (+1)
   \   0000000C   0x2A0D             CMP      R2,#+13
   \   0000000E   0xDBFC             BLT.N    ??DelayUs_2
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \                     ??DelayUs_1: (+1)
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD201             BCS.N    ??DelayUs_4
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xE7F8             B.N      ??DelayUs_3
     12          }
   \                     ??DelayUs_4: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
     13          

   \                                 In section .text, align 2, keep-with-next
     14          void DelayMs(unsigned int ms)
     15          {
     16            int ii,jj;
     17            if (ms<1) ms=1;
   \                     DelayMs: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE.N    ??DelayMs_0
   \   00000004   0x2001             MOVS     R0,#+1
     18            for(ii=0;ii<ms;ii++)
   \                     ??DelayMs_0: (+1)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xE005             B.N      ??DelayMs_1
     19              for(jj=0;jj<8800;jj++);   //50MHz--1ms
   \                     ??DelayMs_2: (+1)
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \                     ??DelayMs_3: (+1)
   \   0000000C   0xF242 0x2360      MOVW     R3,#+8800
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xDBFA             BLT.N    ??DelayMs_2
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \                     ??DelayMs_1: (+1)
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD201             BCS.N    ??DelayMs_4
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0xE7F6             B.N      ??DelayMs_3
     20          }
   \                     ??DelayMs_4: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
     21          

   \                                 In section .text, align 2, keep-with-next
     22          void get_ms(unsigned long *time)
     23          {
     24          
     25          }
   \                     get_ms: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     26          /**
     27          * @fn:         IIC_Init
     28          * @bref:       IIC port initialization
     29          * @params:     none    
     30          * @return:     none
     31          * @version:    0.1
     32          * @date:       2013-1-5 
     33          * 
     34          */

   \                                 In section .text, align 2, keep-with-next
     35          void IIC_Init(void)
     36          {
   \                     IIC_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     37            SDA_OUT();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x400ff040
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x6041             STR      R1,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7301             STRB     R1,[R0, #+12]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6081             STR      R1,[R0, #+8]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000028   0xB084             SUB      SP,SP,#+16
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000032   0xBC0F             POP      {R0-R3}
   \   00000034   0x.... 0x....      BL       LPLD_GPIO_Init
     38            SCL_OUT();
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x400ff040
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000046   0x2104             MOVS     R1,#+4
   \   00000048   0x6041             STR      R1,[R0, #+4]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x7301             STRB     R1,[R0, #+12]
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6081             STR      R1,[R0, #+8]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000005E   0xB084             SUB      SP,SP,#+16
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0x2214             MOVS     R2,#+20
   \   00000064   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000068   0xBC0F             POP      {R0-R3}
   \   0000006A   0x.... 0x....      BL       LPLD_GPIO_Init
     39          }
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
     40          /**
     41          * @fn:         IIC_Start
     42          * @bref:       generate IIC start signal
     43          * @params:     none    
     44          * @return:     none
     45          * @version:    0.1
     46          * @date:       2013-1-5 
     47          * 
     48          */

   \                                 In section .text, align 2, keep-with-next
     49          void IIC_Start(void)
     50          {
   \                     IIC_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     51            SDA_OUT();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x400ff040
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x6041             STR      R1,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7301             STRB     R1,[R0, #+12]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6081             STR      R1,[R0, #+8]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000028   0xB084             SUB      SP,SP,#+16
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000032   0xBC0F             POP      {R0-R3}
   \   00000034   0x.... 0x....      BL       LPLD_GPIO_Init
     52            IIC_SDA(1);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000040   0x.... 0x....      BL       LPLD_GPIO_Output_b
     53            IIC_DelayUs(1);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       DelayUs
     54            IIC_SCL(1);
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000052   0x.... 0x....      BL       LPLD_GPIO_Output_b
     55            IIC_DelayUs(5);
   \   00000056   0x2005             MOVS     R0,#+5
   \   00000058   0x.... 0x....      BL       DelayUs
     56            IIC_SDA(0);
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2103             MOVS     R1,#+3
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000064   0x.... 0x....      BL       LPLD_GPIO_Output_b
     57            IIC_DelayUs(5);
   \   00000068   0x2005             MOVS     R0,#+5
   \   0000006A   0x.... 0x....      BL       DelayUs
     58            IIC_SCL(0);
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x2102             MOVS     R1,#+2
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000076   0x.... 0x....      BL       LPLD_GPIO_Output_b
     59            IIC_DelayUs(2);
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0x.... 0x....      BL       DelayUs
     60          }
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
     61          /**
     62          * @fn:         IIC_Stop
     63          * @bref:       generate IIC stop signal
     64          * @params:     none    
     65          * @return:     none
     66          * @version:    0.1
     67          * @date:       2013-1-5 
     68          * 
     69          */

   \                                 In section .text, align 2, keep-with-next
     70          void IIC_Stop(void)
     71          {
   \                     IIC_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     72            SDA_OUT();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x400ff040
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x6041             STR      R1,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7301             STRB     R1,[R0, #+12]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6081             STR      R1,[R0, #+8]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000028   0xB084             SUB      SP,SP,#+16
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000032   0xBC0F             POP      {R0-R3}
   \   00000034   0x.... 0x....      BL       LPLD_GPIO_Init
     73            IIC_SDA(0);
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000040   0x.... 0x....      BL       LPLD_GPIO_Output_b
     74            IIC_DelayUs(1);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       DelayUs
     75            IIC_SCL(1);
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000052   0x.... 0x....      BL       LPLD_GPIO_Output_b
     76            IIC_DelayUs(5);
   \   00000056   0x2005             MOVS     R0,#+5
   \   00000058   0x.... 0x....      BL       DelayUs
     77            IIC_SDA(1);
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x2103             MOVS     R1,#+3
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000064   0x.... 0x....      BL       LPLD_GPIO_Output_b
     78            IIC_DelayUs(4);							   	
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x.... 0x....      BL       DelayUs
     79          }
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
     80          /**
     81          * @fn:         IIC_NAck
     82          * @bref:       IIC No ACK action
     83          * @params:     none    
     84          * @return:     none
     85          * @version:    0.1
     86          * @date:       2013-1-5 
     87          * 
     88          */
     89          //void IIC_NAck(void)
     90          //{
     91          //  IIC_SCL(0);
     92          //  SDA_OUT();
     93          //  IIC_SDA(1);
     94          //  IIC_DelayUs(1);
     95          //  IIC_SCL(1);
     96          //  IIC_DelayUs(1);
     97          //  IIC_SCL(0);  
     98          //}
     99          ///**
    100          //* @fn:         IIC_NAck
    101          //* @bref:       IIC ACK action
    102          //* @params:     none    
    103          //* @return:     none
    104          //* @version:    0.1
    105          //* @date:       2013-1-5 
    106          //* 
    107          //*/
    108          //void IIC_Ack(void)
    109          //{
    110          //  IIC_SCL(0);
    111          //  SDA_OUT();
    112          //  IIC_SDA(0);
    113          //  IIC_DelayUs(2);
    114          //  IIC_SCL(1);
    115          //  IIC_DelayUs(2);
    116          //  IIC_SCL(0);
    117          //}
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void IIC_SendACK(unsigned char a)  
    120          {  
   \                     IIC_SendACK: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    121            SDA_OUT();  
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x400ff040
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x6041             STR      R1,[R0, #+4]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7301             STRB     R1,[R0, #+12]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6081             STR      R1,[R0, #+8]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000002C   0xB084             SUB      SP,SP,#+16
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x2214             MOVS     R2,#+20
   \   00000032   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000036   0xBC0F             POP      {R0-R3}
   \   00000038   0x.... 0x....      BL       LPLD_GPIO_Init
    122            if(a==0) IIC_SDA(0);           /*在此发出应答或非应答信号 */
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD106             BNE.N    ??IIC_SendACK_0
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x2103             MOVS     R1,#+3
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   0000004A   0x.... 0x....      BL       LPLD_GPIO_Output_b
   \   0000004E   0xE005             B.N      ??IIC_SendACK_1
    123                 else IIC_SDA(1);
   \                     ??IIC_SendACK_0: (+1)
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x2103             MOVS     R1,#+3
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   00000058   0x.... 0x....      BL       LPLD_GPIO_Output_b
    124            IIC_DelayUs(3);      
   \                     ??IIC_SendACK_1: (+1)
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0x.... 0x....      BL       DelayUs
    125            IIC_SCL(1);
   \   00000062   0x2201             MOVS     R2,#+1
   \   00000064   0x2102             MOVS     R1,#+2
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   0000006A   0x.... 0x....      BL       LPLD_GPIO_Output_b
    126            
    127            IIC_DelayUs(5);                     /*时钟低电平周期大于4μs*/
   \   0000006E   0x2005             MOVS     R0,#+5
   \   00000070   0x.... 0x....      BL       DelayUs
    128            
    129            IIC_SCL(0);                      /*清时钟线，钳住I2C总线以便继续接收*/
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x2102             MOVS     R1,#+2
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x400ff040
   \   0000007C   0x.... 0x....      BL       LPLD_GPIO_Output_b
    130            IIC_DelayUs(2);    
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x.... 0x....      BL       DelayUs
    131          }  
   \   00000086   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    132          //
    133          //unsigned char IIC_RecvACK(void)
    134          //{
    135          //  SDA_IN();
    136          //  SCL_OUT();
    137          //  IIC_SCL(1);
    138          //  IIC_DelayUs(1);
    139          //  if(READ_SDA())
    140          //  {
    141          //    IIC_SCL(0);
    142          //    IIC_DelayUs(1);
    143          //    IIC_SCL(1);
    144          //    if(READ_SDA()) return 1;
    145          //  }
    146          //  else return 0;
    147          //}
    148          
    149          
    150          
    151          /**
    152          * @fn:         IIC_SendByte
    153          * @bref:       IIC sned one byte
    154          * @params:     byte to send    
    155          * @return:     none
    156          * @version:    0.1
    157          * @date:       2013-1-5 
    158          * 
    159          */
    160          

   \                                 In section .text, align 2, keep-with-next
    161          void IIC_SendByte(unsigned char dat)
    162          {
   \                     IIC_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    163            unsigned char BitCnt;
    164          
    165            SDA_OUT();  
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x400ff040
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000012   0x2108             MOVS     R1,#+8
   \   00000014   0x6041             STR      R1,[R0, #+4]
   \   00000016   0x....             LDR.N    R0,??DataTable9
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7301             STRB     R1,[R0, #+12]
   \   0000001C   0x....             LDR.N    R0,??DataTable9
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6081             STR      R1,[R0, #+8]
   \   00000022   0x....             LDR.N    R1,??DataTable9
   \   00000024   0xB084             SUB      SP,SP,#+16
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x2214             MOVS     R2,#+20
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0xBC0F             POP      {R0-R3}
   \   00000030   0x.... 0x....      BL       LPLD_GPIO_Init
    166            for(BitCnt=0;BitCnt<8;BitCnt++)   /*要传送的数据长度为8位*/
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE015             B.N      ??IIC_SendByte_0
    167            {
    168              if((dat<<BitCnt)&0x80) IIC_SDA(1);   /*判断发送位*/
    169                else IIC_SDA(0);                
   \                     ??IIC_SendByte_1: (+1)
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000003E   0x.... 0x....      BL       LPLD_GPIO_Output_b
    170              IIC_DelayUs(1);
   \                     ??IIC_SendByte_2: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       DelayUs
    171              IIC_SCL(1);              /*置时钟线为高，通知被控器开始接收数据位*/
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x2102             MOVS     R1,#+2
   \   0000004C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000004E   0x.... 0x....      BL       LPLD_GPIO_Output_b
    172              
    173              IIC_DelayUs(5);              /*保证时钟高电平周期大于4μs*/
   \   00000052   0x2005             MOVS     R0,#+5
   \   00000054   0x.... 0x....      BL       DelayUs
    174                     
    175              IIC_SCL(0); 
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x2102             MOVS     R1,#+2
   \   0000005C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000005E   0x.... 0x....      BL       LPLD_GPIO_Output_b
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
   \                     ??IIC_SendByte_0: (+1)
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D08             CMP      R5,#+8
   \   00000068   0xDA0A             BGE.N    ??IIC_SendByte_3
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0xFA14 0xF005      LSLS     R0,R4,R5
   \   00000070   0x0600             LSLS     R0,R0,#+24
   \   00000072   0xD5E1             BPL.N    ??IIC_SendByte_1
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x2103             MOVS     R1,#+3
   \   00000078   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000007A   0x.... 0x....      BL       LPLD_GPIO_Output_b
   \   0000007E   0xE7E0             B.N      ??IIC_SendByte_2
    176            }
    177            
    178            IIC_DelayUs(2);
   \                     ??IIC_SendByte_3: (+1)
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x.... 0x....      BL       DelayUs
    179            SDA_IN();                 /*8位发送完后释放数据线，准备接收应答位*/
   \   00000086   0x....             LDR.N    R0,??DataTable9
   \   00000088   0x....             LDR.N    R1,??DataTable9_1  ;; 0x400ff040
   \   0000008A   0x6001             STR      R1,[R0, #+0]
   \   0000008C   0x....             LDR.N    R0,??DataTable9
   \   0000008E   0x2108             MOVS     R1,#+8
   \   00000090   0x6041             STR      R1,[R0, #+4]
   \   00000092   0x....             LDR.N    R0,??DataTable9
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x7301             STRB     R1,[R0, #+12]
   \   00000098   0x....             LDR.N    R0,??DataTable9
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x6081             STR      R1,[R0, #+8]
   \   0000009E   0x....             LDR.N    R1,??DataTable9
   \   000000A0   0xB084             SUB      SP,SP,#+16
   \   000000A2   0x4668             MOV      R0,SP
   \   000000A4   0x2214             MOVS     R2,#+20
   \   000000A6   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000AA   0xBC0F             POP      {R0-R3}
   \   000000AC   0x.... 0x....      BL       LPLD_GPIO_Init
    180            IIC_DelayUs(2);  
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x.... 0x....      BL       DelayUs
    181            IIC_SCL(1);
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0x2102             MOVS     R1,#+2
   \   000000BA   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   000000BC   0x.... 0x....      BL       LPLD_GPIO_Output_b
    182            IIC_DelayUs(3);
   \   000000C0   0x2003             MOVS     R0,#+3
   \   000000C2   0x.... 0x....      BL       DelayUs
    183            if(READ_SDA)ack=0;     
   \   000000C6   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff050
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD003             BEQ.N    ??IIC_SendByte_4
   \   000000D2   0x....             LDR.N    R0,??DataTable9_3
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x7001             STRB     R1,[R0, #+0]
   \   000000D8   0xE002             B.N      ??IIC_SendByte_5
    184              else ack=1;         /*判断是否接收到应答信号*/
   \                     ??IIC_SendByte_4: (+1)
   \   000000DA   0x....             LDR.N    R0,??DataTable9_3
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x7001             STRB     R1,[R0, #+0]
    185            IIC_SCL(0);
   \                     ??IIC_SendByte_5: (+1)
   \   000000E0   0x2200             MOVS     R2,#+0
   \   000000E2   0x2102             MOVS     R1,#+2
   \   000000E4   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   000000E6   0x.... 0x....      BL       LPLD_GPIO_Output_b
    186            IIC_DelayUs(2); 
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x.... 0x....      BL       DelayUs
    187          }
   \   000000F0   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    188          /**
    189          * @fn:         IIC_ReadByte
    190          * @bref:       IIC read one byte
    191          * @params:     byte to read    
    192          * @return:     none
    193          * @version:    0.1
    194          * @date:       2013-1-5 
    195          * 
    196          */

   \                                 In section .text, align 2, keep-with-next
    197          unsigned char IIC_ReadByte(void)
    198          {
   \                     IIC_ReadByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    199             unsigned char retc;
    200             unsigned char BitCnt;
    201            
    202             retc=0; 
   \   00000002   0x2400             MOVS     R4,#+0
    203             SDA_IN();               /*置数据线为输入方式*/
   \   00000004   0x....             LDR.N    R0,??DataTable9
   \   00000006   0x....             LDR.N    R1,??DataTable9_1  ;; 0x400ff040
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable9
   \   0000000C   0x2108             MOVS     R1,#+8
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable9
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7301             STRB     R1,[R0, #+12]
   \   00000016   0x....             LDR.N    R0,??DataTable9
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6081             STR      R1,[R0, #+8]
   \   0000001C   0x....             LDR.N    R1,??DataTable9
   \   0000001E   0xB084             SUB      SP,SP,#+16
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000028   0xBC0F             POP      {R0-R3}
   \   0000002A   0x.... 0x....      BL       LPLD_GPIO_Init
    204             for(BitCnt=0;BitCnt<8;BitCnt++)
   \   0000002E   0x2500             MOVS     R5,#+0
   \   00000030   0xE01E             B.N      ??IIC_ReadByte_0
    205             {
    206               IIC_DelayUs(1);   
   \                     ??IIC_ReadByte_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       DelayUs
    207               IIC_SCL(0);                  /*置时钟线为低，准备接收数据位*/
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2102             MOVS     R1,#+2
   \   0000003C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000003E   0x.... 0x....      BL       LPLD_GPIO_Output_b
    208              
    209               IIC_DelayUs(5);                  /*时钟低电平周期大于4.7μs*/
   \   00000042   0x2005             MOVS     R0,#+5
   \   00000044   0x.... 0x....      BL       DelayUs
    210             
    211               IIC_SCL(1);                  /*置时钟线为高使数据线上数据有效*/
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x2102             MOVS     R1,#+2
   \   0000004C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000004E   0x.... 0x....      BL       LPLD_GPIO_Output_b
    212               IIC_DelayUs(3);
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x.... 0x....      BL       DelayUs
    213               retc=retc<<1;
   \   00000058   0x0064             LSLS     R4,R4,#+1
    214               if(READ_SDA) retc=retc+1;   /*读数据位,接收的数据位放入retc中 */
   \   0000005A   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff050
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD000             BEQ.N    ??IIC_ReadByte_2
   \   00000066   0x1C64             ADDS     R4,R4,#+1
    215               IIC_DelayUs(2); 
   \                     ??IIC_ReadByte_2: (+1)
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x.... 0x....      BL       DelayUs
    216             }
   \   0000006E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??IIC_ReadByte_0: (+1)
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D08             CMP      R5,#+8
   \   00000074   0xDBDD             BLT.N    ??IIC_ReadByte_1
    217             IIC_SCL(0);   
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2102             MOVS     R1,#+2
   \   0000007A   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000007C   0x.... 0x....      BL       LPLD_GPIO_Output_b
    218             IIC_DelayUs(2);
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x.... 0x....      BL       DelayUs
    219             return(retc);
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    220          }
    221          

   \                                 In section .text, align 2, keep-with-next
    222          char i2cWriteBuffer(unsigned char addr, unsigned char reg, unsigned char len, unsigned char * data)
    223          {  
   \                     i2cWriteBuffer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x001D             MOVS     R5,R3
    224              unsigned char i;
    225          
    226              IIC_Start();                /*启动总线*/
   \   0000000A   0x.... 0x....      BL       IIC_Start
    227              IIC_SendByte(addr<<1 + 0);              /*发送器件地址*/
   \   0000000E   0x0070             LSLS     R0,R6,#+1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       IIC_SendByte
    228              if(ack==0)return(1);
   \   00000016   0x....             LDR.N    R0,??DataTable9_3
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??i2cWriteBuffer_0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE01D             B.N      ??i2cWriteBuffer_1
    229              IIC_SendByte(reg);             /*发送器件子地址*/
   \                     ??i2cWriteBuffer_0: (+1)
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       IIC_SendByte
    230              if(ack==0)return(1);
   \   0000002A   0x....             LDR.N    R0,??DataTable9_3
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD101             BNE.N    ??i2cWriteBuffer_2
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE013             B.N      ??i2cWriteBuffer_1
    231              for(i=0;i<len;i++)
   \                     ??i2cWriteBuffer_2: (+1)
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE001             B.N      ??i2cWriteBuffer_3
    232              {   
    233                IIC_SendByte(*data);             /*发送数据*/
    234                if(ack==0)return(1);
    235                data++;
   \                     ??i2cWriteBuffer_4: (+1)
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \                     ??i2cWriteBuffer_3: (+1)
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x42A6             CMP      R6,R4
   \   00000044   0xD208             BCS.N    ??i2cWriteBuffer_5
   \   00000046   0x7828             LDRB     R0,[R5, #+0]
   \   00000048   0x.... 0x....      BL       IIC_SendByte
   \   0000004C   0x....             LDR.N    R0,??DataTable9_3
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD1F2             BNE.N    ??i2cWriteBuffer_4
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xE002             B.N      ??i2cWriteBuffer_1
    236              } 
    237              IIC_Stop();                 /*结束总线*/ 
   \                     ??i2cWriteBuffer_5: (+1)
   \   00000058   0x.... 0x....      BL       IIC_Stop
    238          
    239              return(0);
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??i2cWriteBuffer_1: (+1)
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    240          }  
    241          

   \                                 In section .text, align 2, keep-with-next
    242          char i2cRead(unsigned char addr, unsigned char reg, unsigned char len, unsigned char *buf)
    243          {  
   \                     i2cRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x001D             MOVS     R5,R3
    244              unsigned char i;
    245          
    246              IIC_Start();                 /*启动总线*/
   \   0000000A   0x.... 0x....      BL       IIC_Start
    247              IIC_SendByte((addr<<1) + 0);                 /*发送器件地址*/
   \   0000000E   0x0070             LSLS     R0,R6,#+1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       IIC_SendByte
    248              if(ack==0)return(1);
   \   00000016   0x....             LDR.N    R0,??DataTable9_3
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??i2cRead_0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE02F             B.N      ??i2cRead_1
    249              IIC_SendByte(reg);                /*发送器件子地址*/
   \                     ??i2cRead_0: (+1)
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       IIC_SendByte
    250              if(ack==0)return(1);
   \   0000002A   0x....             LDR.N    R0,??DataTable9_3
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD101             BNE.N    ??i2cRead_2
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE025             B.N      ??i2cRead_1
    251              IIC_Start();     /*重新启动总线*/
   \                     ??i2cRead_2: (+1)
   \   00000036   0x.... 0x....      BL       IIC_Start
    252              IIC_SendByte((addr<<1) + 1);
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x0070             LSLS     R0,R6,#+1
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x.... 0x....      BL       IIC_SendByte
    253              if(ack==0)return(1);
   \   00000046   0x....             LDR.N    R0,??DataTable9_3
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD101             BNE.N    ??i2cRead_3
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE017             B.N      ??i2cRead_1
    254              for(i=0;i<len-1;i++)
   \                     ??i2cRead_3: (+1)
   \   00000052   0x2600             MOVS     R6,#+0
   \   00000054   0xE007             B.N      ??i2cRead_4
    255              {   
    256                *buf=IIC_ReadByte();                /*发送数据*/
   \                     ??i2cRead_5: (+1)
   \   00000056   0x.... 0x....      BL       IIC_ReadByte
   \   0000005A   0x7028             STRB     R0,[R5, #+0]
    257                IIC_SendACK(0);                 /*发送就答位*/  
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      BL       IIC_SendACK
    258                buf++;
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
    259              } 
   \   00000064   0x1C76             ADDS     R6,R6,#+1
   \                     ??i2cRead_4: (+1)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0x1E60             SUBS     R0,R4,#+1
   \   0000006C   0x4286             CMP      R6,R0
   \   0000006E   0xDBF2             BLT.N    ??i2cRead_5
    260              *buf=IIC_ReadByte();
   \   00000070   0x.... 0x....      BL       IIC_ReadByte
   \   00000074   0x7028             STRB     R0,[R5, #+0]
    261              IIC_SendACK(1);                    /*发送非应位*/
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x.... 0x....      BL       IIC_SendACK
    262              IIC_Stop();                     /*结束总线*/ 
   \   0000007C   0x.... 0x....      BL       IIC_Stop
    263              return(0);
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??i2cRead_1: (+1)
   \   00000082   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    264          }  
    265          
    266          

   \                                 In section .text, align 2, keep-with-next
    267          unsigned char HMC5883_RecvByte(void)
    268          {
   \                     HMC5883_RecvByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    269            unsigned char i,receive=0;
   \   00000002   0x2400             MOVS     R4,#+0
    270            SDA_IN();
   \   00000004   0x....             LDR.N    R0,??DataTable9
   \   00000006   0x....             LDR.N    R1,??DataTable9_1  ;; 0x400ff040
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable9
   \   0000000C   0x2108             MOVS     R1,#+8
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable9
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7301             STRB     R1,[R0, #+12]
   \   00000016   0x....             LDR.N    R0,??DataTable9
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6081             STR      R1,[R0, #+8]
   \   0000001C   0x....             LDR.N    R1,??DataTable9
   \   0000001E   0xB084             SUB      SP,SP,#+16
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000028   0xBC0F             POP      {R0-R3}
   \   0000002A   0x.... 0x....      BL       LPLD_GPIO_Init
    271            for(i=0;i<8;i++ )
   \   0000002E   0x2500             MOVS     R5,#+0
   \   00000030   0xE018             B.N      ??HMC5883_RecvByte_0
    272            {
    273              IIC_SCL(0); 
   \                     ??HMC5883_RecvByte_1: (+1)
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2102             MOVS     R1,#+2
   \   00000036   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   00000038   0x.... 0x....      BL       LPLD_GPIO_Output_b
    274              DelayUs(2);
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x.... 0x....      BL       DelayUs
    275              IIC_SCL(1);
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x2102             MOVS     R1,#+2
   \   00000046   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   00000048   0x.... 0x....      BL       LPLD_GPIO_Output_b
    276              receive<<=1;
   \   0000004C   0x0064             LSLS     R4,R4,#+1
    277              if(READ_SDA)
   \   0000004E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff050
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD000             BEQ.N    ??HMC5883_RecvByte_2
    278                receive++;   
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
    279              DelayUs(1); 
   \                     ??HMC5883_RecvByte_2: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       DelayUs
    280            }
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HMC5883_RecvByte_0: (+1)
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D08             CMP      R5,#+8
   \   00000068   0xDBE3             BLT.N    ??HMC5883_RecvByte_1
    281            return receive;
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    282          }

   \                                 In section .text, align 2, keep-with-next
    283          void HMC5883_SendByte(unsigned char dat)
    284          {
   \                     HMC5883_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    285            unsigned char i;
    286            SDA_OUT();
   \   00000004   0x....             LDR.N    R0,??DataTable9
   \   00000006   0x....             LDR.N    R1,??DataTable9_1  ;; 0x400ff040
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable9
   \   0000000C   0x2108             MOVS     R1,#+8
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable9
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x7301             STRB     R1,[R0, #+12]
   \   00000016   0x....             LDR.N    R0,??DataTable9
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6081             STR      R1,[R0, #+8]
   \   0000001C   0x....             LDR.N    R1,??DataTable9
   \   0000001E   0xB084             SUB      SP,SP,#+16
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000028   0xBC0F             POP      {R0-R3}
   \   0000002A   0x.... 0x....      BL       LPLD_GPIO_Init
    287            for(i=0;i<8;i++)
   \   0000002E   0x2500             MOVS     R5,#+0
   \   00000030   0xE016             B.N      ??HMC5883_SendByte_0
    288            {
    289              if(dat&0x80) 
    290                IIC_SDA(1);
    291              else 
    292                IIC_SDA(0);
   \                     ??HMC5883_SendByte_1: (+1)
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2103             MOVS     R1,#+3
   \   00000036   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   00000038   0x.... 0x....      BL       LPLD_GPIO_Output_b
    293              dat<<=1;
   \                     ??HMC5883_SendByte_2: (+1)
   \   0000003C   0x0064             LSLS     R4,R4,#+1
    294              DelayUs(5);
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0x.... 0x....      BL       DelayUs
    295              IIC_SCL(1);
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000004A   0x.... 0x....      BL       LPLD_GPIO_Output_b
    296              DelayUs(5);
   \   0000004E   0x2005             MOVS     R0,#+5
   \   00000050   0x.... 0x....      BL       DelayUs
    297              IIC_SCL(0);
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   0000005A   0x.... 0x....      BL       LPLD_GPIO_Output_b
   \   0000005E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HMC5883_SendByte_0: (+1)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D08             CMP      R5,#+8
   \   00000064   0xDA07             BGE.N    ??HMC5883_SendByte_3
   \   00000066   0x0620             LSLS     R0,R4,#+24
   \   00000068   0xD5E3             BPL.N    ??HMC5883_SendByte_1
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x2103             MOVS     R1,#+3
   \   0000006E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x400ff040
   \   00000070   0x.... 0x....      BL       LPLD_GPIO_Output_b
   \   00000074   0xE7E2             B.N      ??HMC5883_SendByte_2
    298            }
    299            IIC_RecvACK();
   \                     ??HMC5883_SendByte_3: (+1)
   \   00000076   0x.... 0x....      BL       IIC_RecvACK
    300          }
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     gpio_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF050         DC32     0x400ff050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     ack

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DelayMs
       0   DelayUs
      32   HMC5883_RecvByte
        16   -> DelayUs
        16   -> LPLD_GPIO_Init
        16   -> LPLD_GPIO_Output_b
        32   -> __aeabi_memcpy4
      32   HMC5883_SendByte
        16   -> DelayUs
        16   -> IIC_RecvACK
        16   -> LPLD_GPIO_Init
        16   -> LPLD_GPIO_Output_b
        32   -> __aeabi_memcpy4
      24   IIC_Init
         8   -> LPLD_GPIO_Init
        24   -> __aeabi_memcpy4
      32   IIC_ReadByte
        16   -> DelayUs
        16   -> LPLD_GPIO_Init
        16   -> LPLD_GPIO_Output_b
        32   -> __aeabi_memcpy4
      32   IIC_SendACK
        16   -> DelayUs
        16   -> LPLD_GPIO_Init
        16   -> LPLD_GPIO_Output_b
        32   -> __aeabi_memcpy4
      32   IIC_SendByte
        16   -> DelayUs
        16   -> LPLD_GPIO_Init
        16   -> LPLD_GPIO_Output_b
        32   -> __aeabi_memcpy4
      24   IIC_Start
         8   -> DelayUs
         8   -> LPLD_GPIO_Init
         8   -> LPLD_GPIO_Output_b
        24   -> __aeabi_memcpy4
      24   IIC_Stop
         8   -> DelayUs
         8   -> LPLD_GPIO_Init
         8   -> LPLD_GPIO_Output_b
        24   -> __aeabi_memcpy4
       0   get_ms
      24   i2cRead
        24   -> IIC_ReadByte
        24   -> IIC_SendACK
        24   -> IIC_SendByte
        24   -> IIC_Start
        24   -> IIC_Stop
      24   i2cWriteBuffer
        24   -> IIC_SendByte
        24   -> IIC_Start
        24   -> IIC_Stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
      32  DelayMs
      28  DelayUs
     112  HMC5883_RecvByte
     124  HMC5883_SendByte
     112  IIC_Init
     140  IIC_ReadByte
     136  IIC_SendACK
     242  IIC_SendByte
     130  IIC_Start
     112  IIC_Stop
       1  ack
       2  get_ms
     132  i2cRead
      96  i2cWriteBuffer

 
     1 byte  in section .bss
 1 414 bytes in section .text
 
 1 414 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
