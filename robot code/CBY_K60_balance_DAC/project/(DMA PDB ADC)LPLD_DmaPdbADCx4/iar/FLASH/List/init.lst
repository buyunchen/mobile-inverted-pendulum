###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.70.2.6274/W32 for ARM      11/May/2020  12:22:53 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Current Projects\#1 Memristor tuning                  #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\app\init.c                          #
#    Command line =  "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\app\init.c" -D LPLD_K60 -lCN        #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\" -lB "D:\Current    #
#                    Projects\#1 Memristor tuning circuit\memristor based     #
#                    control\mcu code\paper code\0.1ms control period\test    #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\" -o "D:\Current     #
#                    Projects\#1 Memristor tuning circuit\memristor based     #
#                    control\mcu code\paper code\0.1ms control period\test    #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5_2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Current     #
#                    Projects\#1 Memristor tuning circuit\memristor based     #
#                    control\mcu code\paper code\0.1ms control period\test    #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\app\" -I "D:\Current         #
#                    Projects\#1 Memristor tuning circuit\memristor based     #
#                    control\mcu code\paper code\0.1ms control period\test    #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\CPU\" -I           #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\common\" -I        #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\" -I          #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\HW\" -I       #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\LPLD\DEV\" -I      #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\uCOS-II\Ports\"    #
#                    -I "D:\Current Projects\#1 Memristor tuning              #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\uCOS-II\Source\"   #
#                    -I "D:\Current Projects\#1 Memristor tuning              #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\FatFs\" -I         #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\FatFs\option\" -I  #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\common\" -I    #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\driver\" -I    #
#                    "D:\Current Projects\#1 Memristor tuning                 #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\descriptor\"   #
#                    -I "D:\Current Projects\#1 Memristor tuning              #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\..\..\..\lib\USB\class\" -Ol    #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5_2\arm\CMSIS\Include\" -D ARM_MATH_CM4      #
#    List file    =  D:\Current Projects\#1 Memristor tuning                  #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\List\init.lst             #
#    Object file  =  D:\Current Projects\#1 Memristor tuning                  #
#                    circuit\memristor based control\mcu code\paper           #
#                    code\0.1ms control period\test                           #
#                    code\CBY_K60_balance_DAC\project\(DMA PDB                #
#                    ADC)LPLD_DmaPdbADCx4\iar\FLASH\Obj\init.o                #
#                                                                             #
#                                                                             #
###############################################################################

D:\Current Projects\#1 Memristor tuning circuit\memristor based control\mcu code\paper code\0.1ms control period\test code\CBY_K60_balance_DAC\project\(DMA PDB ADC)LPLD_DmaPdbADCx4\app\init.c
      1           #include "common.h"
      2          
      3          //结构体变量声明

   \                                 In section .bss, align 4
      4          GPIO_InitTypeDef gpio_init_struct;
   \                     gpio_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
      5          PIT_InitTypeDef pit2_init_struct;
   \                     pit2_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
      6          PIT_InitTypeDef pit1_init_struct;
   \                     pit1_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
      7          ADC_InitTypeDef adc_init_struct;
   \                     adc_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
      8          DMA_InitTypeDef dma_init_struct;
   \                     dma_init_struct:
   \   00000000                      DS8 44

   \                                 In section .bss, align 4
      9          UART_InitTypeDef uart0_init_struct;
   \                     uart0_init_struct:
   \   00000000                      DS8 20
     10          
     11          /**初始化ADC及其通道**/

   \                                 In section .text, align 2, keep-with-next
     12          void adc_init(void)
     13          {
   \                     adc_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     14              adc_init_struct.ADC_Adcx = ADC0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0x4003b000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
     15              adc_init_struct.ADC_DiffMode = ADC_SE;        //单端采集
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7101             STRB     R1,[R0, #+4]
     16              adc_init_struct.ADC_BitMode = SE_16BIT;      
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x7141             STRB     R1,[R0, #+5]
     17              adc_init_struct.ADC_SampleTimeCfg = SAMTIME_SHORT;    //短采样时间
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7181             STRB     R1,[R0, #+6]
     18              adc_init_struct.ADC_HwAvgSel = HW_4AVG;       //4次硬件平均
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x7201             STRB     R1,[R0, #+8]
     19              adc_init_struct.ADC_CalEnable = TRUE; //使能初始化校验  使能就不行了
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x72C1             STRB     R1,[R0, #+11]
     20              LPLD_ADC_Init(adc_init_struct);
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000038   0xB084             SUB      SP,SP,#+16
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x2214             MOVS     R2,#+20
   \   0000003E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000042   0xBC0F             POP      {R0-R3}
   \   00000044   0x.... 0x....      BL       LPLD_ADC_Init
     21              LPLD_ADC_DisableIrq(adc_init_struct);   
   \   00000048   0x....             LDR.N    R1,??DataTable8
   \   0000004A   0xB084             SUB      SP,SP,#+16
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x2214             MOVS     R2,#+20
   \   00000050   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000054   0xBC0F             POP      {R0-R3}
   \   00000056   0x.... 0x....      BL       LPLD_ADC_DisableIrq
     22              LPLD_ADC_Chn_Enable(ADC0, AD14); 
   \   0000005A   0x210E             MOVS     R1,#+14
   \   0000005C   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4003b000
   \   0000005E   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     23              LPLD_ADC_Chn_Enable(ADC0, AD15); 
   \   00000062   0x210F             MOVS     R1,#+15
   \   00000064   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4003b000
   \   00000066   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     24              LPLD_ADC_Chn_Enable(ADC0, AD4); 
   \   0000006A   0x2104             MOVS     R1,#+4
   \   0000006C   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4003b000
   \   0000006E   0x.... 0x....      BL       LPLD_ADC_Chn_Enable
     25          }
   \   00000072   0xBD01             POP      {R0,PC}          ;; return
     26          /**初始化gpio**/

   \                                 In section .text, align 2, keep-with-next
     27          void init_gpio(int init_i)
     28          {
   \                     init_gpio: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
     29            GPIO_InitTypeDef gpio_init_struct={0};
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
     30            switch(init_i)
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD00F             BEQ.N    ??init_gpio_0
   \   00000012   0xF0C0 0x80C0      BCC.W    ??init_gpio_1
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD03E             BEQ.N    ??init_gpio_2
   \   0000001A   0xD31D             BCC.N    ??init_gpio_3
   \   0000001C   0x2C05             CMP      R4,#+5
   \   0000001E   0xD062             BEQ.N    ??init_gpio_4
   \   00000020   0xD34E             BCC.N    ??init_gpio_5
   \   00000022   0x2C07             CMP      R4,#+7
   \   00000024   0xF000 0x8091      BEQ.W    ??init_gpio_6
   \   00000028   0xD37C             BCC.N    ??init_gpio_7
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xF000 0x80A0      BEQ.W    ??init_gpio_8
   \   00000030   0xE0B1             B.N      ??init_gpio_1
     31            {
     32            case 1:
     33              // 配置0d3 1d2 rd1 cd0为GPIO功能,输出 oled
     34              gpio_init_struct.GPIO_PTx = PTD;      
   \                     ??init_gpio_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable8_2  ;; 0x400ff0c0
   \   00000034   0x9001             STR      R0,[SP, #+4]
     35              gpio_init_struct.GPIO_Pins = GPIO_Pin0|GPIO_Pin1|GPIO_Pin2|GPIO_Pin3;     //引脚6、7
   \   00000036   0x200F             MOVS     R0,#+15
   \   00000038   0x9002             STR      R0,[SP, #+8]
     36              gpio_init_struct.GPIO_Output=OUTPUT_L;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF88D 0x0011      STRB     R0,[SP, #+17]
     37              gpio_init_struct.GPIO_PinControl = IRQC_DIS;     
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9003             STR      R0,[SP, #+12]
     38              LPLD_GPIO_Init(gpio_init_struct);
   \   00000044   0xA901             ADD      R1,SP,#+4
   \   00000046   0xB084             SUB      SP,SP,#+16
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x2214             MOVS     R2,#+20
   \   0000004C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000050   0xBC0F             POP      {R0-R3}
   \   00000052   0x.... 0x....      BL       LPLD_GPIO_Init
     39              break;
   \   00000056   0xE09E             B.N      ??init_gpio_9
     40            /*case 2:
     41              // 配置0d3 1d2 rd1 cd0为GPIO功能,输出 oled
     42              
     43              gpio_init_struct.GPIO_PTx = PTB;      //PORTC
     44              gpio_init_struct.GPIO_Pins = GPIO_Pin21|GPIO_Pin22;//|GPIO_Pin2|GPIO_Pin3;     //引脚6、7
     45              gpio_init_struct.GPIO_Output=OUTPUT_L;
     46              gpio_init_struct.GPIO_PinControl = IRQC_DIS;     
     47              LPLD_GPIO_Init(gpio_init_struct);
     48              break;
     49            case 3:
     50              // 配置0d3 1d2 rd1 cd0为GPIO功能,输出 oled
     51              
     52              gpio_init_struct.GPIO_PTx = PTC;      //PORTC
     53              gpio_init_struct.GPIO_Pins = GPIO_Pin4|GPIO_Pin3|GPIO_Pin8|GPIO_Pin5|GPIO_Pin6|GPIO_Pin7|GPIO_Pin9|GPIO_Pin12;     //引脚6、7
     54              gpio_init_struct.GPIO_Output=OUTPUT_L;
     55              gpio_init_struct.GPIO_PinControl = IRQC_DIS;     
     56              LPLD_GPIO_Init(gpio_init_struct);
     57              break;*/
     58            //case 2:
     59              //gpio_init_struct.GPIO_PTx = PTE;    
     60              //gpio_init_struct.GPIO_Pins = GPIO_Pin26; 
     61              //gpio_init_struct.GPIO_Dir = OUTPUT_L;      
     62              //gpio_init_struct.GPIO_PinControl = IRQC_DIS;   
     63              //LPLD_GPIO_Init(gpio_init_struct);
     64              /////////////////////旋钮1/////////////////////////////////////////////////////////////
     65             case 2: 
     66              gpio_init_struct.GPIO_PTx = PTC;      //PORTC8C12C7
   \                     ??init_gpio_3: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable8_3  ;; 0x400ff080
   \   0000005A   0x9001             STR      R0,[SP, #+4]
     67              gpio_init_struct.GPIO_Pins = GPIO_Pin8;
   \   0000005C   0xF44F 0x7080      MOV      R0,#+256
   \   00000060   0x9002             STR      R0,[SP, #+8]
     68              gpio_init_struct.GPIO_Output=DIR_INPUT;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF88D 0x0011      STRB     R0,[SP, #+17]
     69              gpio_init_struct.GPIO_PinControl = INPUT_PF_DIS|IRQC_FA;   //输入低通滤波，下降沿中断
   \   00000068   0xF45F 0x2020      MOVS     R0,#+655360
   \   0000006C   0x9003             STR      R0,[SP, #+12]
     70              gpio_init_struct.GPIO_Isr = portc_isr;        //中断函数
   \   0000006E   0x....             LDR.N    R0,??DataTable8_4
   \   00000070   0x9005             STR      R0,[SP, #+20]
     71              LPLD_GPIO_Init(gpio_init_struct);
   \   00000072   0xA901             ADD      R1,SP,#+4
   \   00000074   0xB084             SUB      SP,SP,#+16
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x2214             MOVS     R2,#+20
   \   0000007A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000007E   0xBC0F             POP      {R0-R3}
   \   00000080   0x.... 0x....      BL       LPLD_GPIO_Init
     72              //使能中断
     73              LPLD_GPIO_EnableIrq(gpio_init_struct);
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0xB084             SUB      SP,SP,#+16
   \   00000088   0x4668             MOV      R0,SP
   \   0000008A   0x2214             MOVS     R2,#+20
   \   0000008C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000090   0xBC0F             POP      {R0-R3}
   \   00000092   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
     74              break;
   \   00000096   0xE07E             B.N      ??init_gpio_9
     75            case 3:
     76              
     77              gpio_init_struct.GPIO_PTx = PTC;      //PORTC4C6C8
   \                     ??init_gpio_2: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable8_3  ;; 0x400ff080
   \   0000009A   0x9001             STR      R0,[SP, #+4]
     78              gpio_init_struct.GPIO_Pins = GPIO_Pin12;
   \   0000009C   0xF44F 0x5080      MOV      R0,#+4096
   \   000000A0   0x9002             STR      R0,[SP, #+8]
     79              gpio_init_struct.GPIO_Output=DIR_INPUT;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x0011      STRB     R0,[SP, #+17]
     80              gpio_init_struct.GPIO_PinControl = INPUT_PF_EN;   //输入低通滤波
   \   000000A8   0x2010             MOVS     R0,#+16
   \   000000AA   0x9003             STR      R0,[SP, #+12]
     81              LPLD_GPIO_Init(gpio_init_struct);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0xB084             SUB      SP,SP,#+16
   \   000000B0   0x4668             MOV      R0,SP
   \   000000B2   0x2214             MOVS     R2,#+20
   \   000000B4   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000B8   0xBC0F             POP      {R0-R3}
   \   000000BA   0x.... 0x....      BL       LPLD_GPIO_Init
     82              break;
   \   000000BE   0xE06A             B.N      ??init_gpio_9
     83            case 4:
     84              
     85              gpio_init_struct.GPIO_PTx = PTC;      //PORTC4C6C8
   \                     ??init_gpio_5: (+1)
   \   000000C0   0x....             LDR.N    R0,??DataTable8_3  ;; 0x400ff080
   \   000000C2   0x9001             STR      R0,[SP, #+4]
     86              gpio_init_struct.GPIO_Pins = GPIO_Pin7;
   \   000000C4   0x2080             MOVS     R0,#+128
   \   000000C6   0x9002             STR      R0,[SP, #+8]
     87              gpio_init_struct.GPIO_Output=DIR_INPUT;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF88D 0x0011      STRB     R0,[SP, #+17]
     88              gpio_init_struct.GPIO_PinControl = INPUT_PULL_UP;   //输入低通滤波
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0x9003             STR      R0,[SP, #+12]
     89              LPLD_GPIO_Init(gpio_init_struct);
   \   000000D2   0xA901             ADD      R1,SP,#+4
   \   000000D4   0xB084             SUB      SP,SP,#+16
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x2214             MOVS     R2,#+20
   \   000000DA   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000DE   0xBC0F             POP      {R0-R3}
   \   000000E0   0x.... 0x....      BL       LPLD_GPIO_Init
     90              break;
   \   000000E4   0xE057             B.N      ??init_gpio_9
     91            case 5:
     92              /////////////////旋钮2///////////////////////////////////////////////////////////////
     93              
     94              gpio_init_struct.GPIO_PTx = PTC;      //PORTC5C3C4
   \                     ??init_gpio_4: (+1)
   \   000000E6   0x....             LDR.N    R0,??DataTable8_3  ;; 0x400ff080
   \   000000E8   0x9001             STR      R0,[SP, #+4]
     95              gpio_init_struct.GPIO_Pins = GPIO_Pin5;
   \   000000EA   0x2020             MOVS     R0,#+32
   \   000000EC   0x9002             STR      R0,[SP, #+8]
     96              gpio_init_struct.GPIO_Output=DIR_INPUT;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF88D 0x0011      STRB     R0,[SP, #+17]
     97              gpio_init_struct.GPIO_PinControl = INPUT_PF_DIS|IRQC_FA;   //输入低通滤波，下降沿中断
   \   000000F4   0xF45F 0x2020      MOVS     R0,#+655360
   \   000000F8   0x9003             STR      R0,[SP, #+12]
     98              gpio_init_struct.GPIO_Isr = portc_isr;        //中断函数
   \   000000FA   0x....             LDR.N    R0,??DataTable8_4
   \   000000FC   0x9005             STR      R0,[SP, #+20]
     99              LPLD_GPIO_Init(gpio_init_struct);
   \   000000FE   0xA901             ADD      R1,SP,#+4
   \   00000100   0xB084             SUB      SP,SP,#+16
   \   00000102   0x4668             MOV      R0,SP
   \   00000104   0x2214             MOVS     R2,#+20
   \   00000106   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000010A   0xBC0F             POP      {R0-R3}
   \   0000010C   0x.... 0x....      BL       LPLD_GPIO_Init
    100              //使能中断
    101              LPLD_GPIO_EnableIrq(gpio_init_struct);
   \   00000110   0xA901             ADD      R1,SP,#+4
   \   00000112   0xB084             SUB      SP,SP,#+16
   \   00000114   0x4668             MOV      R0,SP
   \   00000116   0x2214             MOVS     R2,#+20
   \   00000118   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000011C   0xBC0F             POP      {R0-R3}
   \   0000011E   0x.... 0x....      BL       LPLD_GPIO_EnableIrq
    102              break;
   \   00000122   0xE038             B.N      ??init_gpio_9
    103            case 6:
    104              
    105              gpio_init_struct.GPIO_PTx = PTC;      
   \                     ??init_gpio_7: (+1)
   \   00000124   0x....             LDR.N    R0,??DataTable8_3  ;; 0x400ff080
   \   00000126   0x9001             STR      R0,[SP, #+4]
    106              gpio_init_struct.GPIO_Pins = GPIO_Pin3;
   \   00000128   0x2008             MOVS     R0,#+8
   \   0000012A   0x9002             STR      R0,[SP, #+8]
    107              gpio_init_struct.GPIO_Output=DIR_INPUT;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF88D 0x0011      STRB     R0,[SP, #+17]
    108              gpio_init_struct.GPIO_PinControl = INPUT_PF_EN;   //输入低通滤波
   \   00000132   0x2010             MOVS     R0,#+16
   \   00000134   0x9003             STR      R0,[SP, #+12]
    109              LPLD_GPIO_Init(gpio_init_struct);
   \   00000136   0xA901             ADD      R1,SP,#+4
   \   00000138   0xB084             SUB      SP,SP,#+16
   \   0000013A   0x4668             MOV      R0,SP
   \   0000013C   0x2214             MOVS     R2,#+20
   \   0000013E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000142   0xBC0F             POP      {R0-R3}
   \   00000144   0x.... 0x....      BL       LPLD_GPIO_Init
    110              break;
   \   00000148   0xE025             B.N      ??init_gpio_9
    111            case 7:
    112              
    113              gpio_init_struct.GPIO_PTx = PTC;      
   \                     ??init_gpio_6: (+1)
   \   0000014A   0x....             LDR.N    R0,??DataTable8_3  ;; 0x400ff080
   \   0000014C   0x9001             STR      R0,[SP, #+4]
    114              gpio_init_struct.GPIO_Pins = GPIO_Pin4;
   \   0000014E   0x2010             MOVS     R0,#+16
   \   00000150   0x9002             STR      R0,[SP, #+8]
    115              gpio_init_struct.GPIO_Output=DIR_INPUT;
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF88D 0x0011      STRB     R0,[SP, #+17]
    116              gpio_init_struct.GPIO_PinControl = INPUT_PF_EN;   //输入低通滤波
   \   00000158   0x2010             MOVS     R0,#+16
   \   0000015A   0x9003             STR      R0,[SP, #+12]
    117              LPLD_GPIO_Init(gpio_init_struct);   
   \   0000015C   0xA901             ADD      R1,SP,#+4
   \   0000015E   0xB084             SUB      SP,SP,#+16
   \   00000160   0x4668             MOV      R0,SP
   \   00000162   0x2214             MOVS     R2,#+20
   \   00000164   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000168   0xBC0F             POP      {R0-R3}
   \   0000016A   0x.... 0x....      BL       LPLD_GPIO_Init
    118              break;
   \   0000016E   0xE012             B.N      ??init_gpio_9
    119            case 8:
    120              ////////////////////////////////////////////////////////////////////////////////
    121              // 配置B0 1 18 19
    122              
    123              gpio_init_struct.GPIO_PTx = PTB;      //PORTB
   \                     ??init_gpio_8: (+1)
   \   00000170   0x....             LDR.N    R0,??DataTable8_5  ;; 0x400ff040
   \   00000172   0x9001             STR      R0,[SP, #+4]
    124              gpio_init_struct.GPIO_Pins = GPIO_Pin0|GPIO_Pin1|GPIO_Pin18|GPIO_Pin19;     //引脚0、1
   \   00000174   0x....             LDR.N    R0,??DataTable8_6  ;; 0xc0003
   \   00000176   0x9002             STR      R0,[SP, #+8]
    125              gpio_init_struct.GPIO_Dir = DIR_INPUT;        //输入
   \   00000178   0x2000             MOVS     R0,#+0
   \   0000017A   0xF88D 0x0010      STRB     R0,[SP, #+16]
    126              gpio_init_struct.GPIO_PinControl = INPUT_PULL_UP;     //内部上拉
   \   0000017E   0x2003             MOVS     R0,#+3
   \   00000180   0x9003             STR      R0,[SP, #+12]
    127              LPLD_GPIO_Init(gpio_init_struct);
   \   00000182   0xA901             ADD      R1,SP,#+4
   \   00000184   0xB084             SUB      SP,SP,#+16
   \   00000186   0x4668             MOV      R0,SP
   \   00000188   0x2214             MOVS     R2,#+20
   \   0000018A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000018E   0xBC0F             POP      {R0-R3}
   \   00000190   0x.... 0x....      BL       LPLD_GPIO_Init
    128              break;
   \   00000194   0xE7FF             B.N      ??init_gpio_9
    129            default:
    130              break;
    131            }
    132          }
   \                     ??init_gpio_1: (+1)
   \                     ??init_gpio_9: (+1)
   \   00000196   0xB006             ADD      SP,SP,#+24
   \   00000198   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    133          void testa15(void)
    134          {
   \                     testa15: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    135            GPIO_InitTypeDef gpio_init_struct={0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
    136            gpio_init_struct.GPIO_PTx = PTA;    
   \   0000000C   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400ff000
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    137            gpio_init_struct.GPIO_Pins = GPIO_Pin15; 
   \   00000010   0xF44F 0x4000      MOV      R0,#+32768
   \   00000014   0x9002             STR      R0,[SP, #+8]
    138            gpio_init_struct.GPIO_Dir = OUTPUT_H;      
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF88D 0x0010      STRB     R0,[SP, #+16]
    139            gpio_init_struct.GPIO_PinControl = IRQC_DIS;   
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9003             STR      R0,[SP, #+12]
    140            LPLD_GPIO_Init(gpio_init_struct);
   \   00000020   0xA901             ADD      R1,SP,#+4
   \   00000022   0xB084             SUB      SP,SP,#+16
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002C   0xBC0F             POP      {R0-R3}
   \   0000002E   0x.... 0x....      BL       LPLD_GPIO_Init
    141          }
   \   00000032   0xB007             ADD      SP,SP,#+28
   \   00000034   0xBD00             POP      {PC}             ;; return
    142          
    143          //初始化PIT0和PIT1通道
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void pit1_init(void)
    146          {
   \                     pit1_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    147            //配置PIT1参数
    148            pit1_init_struct.PIT_Pitx = PIT1;
   \   00000002   0x....             LDR.N    R0,??DataTable8_8
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    149            pit1_init_struct.PIT_PeriodMs = 5; //定时周期1毫秒
   \   00000008   0x....             LDR.N    R0,??DataTable8_8
   \   0000000A   0x2105             MOVS     R1,#+5
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    150            //pit1_init_struct.PIT_PeriodUs = 100;
    151            pit1_init_struct.PIT_Isr = pit1_isr;  //设置中断函数
   \   0000000E   0x....             LDR.N    R0,??DataTable8_8
   \   00000010   0x....             LDR.N    R1,??DataTable8_9
   \   00000012   0x6101             STR      R1,[R0, #+16]
    152            //初始化PIT1
    153            LPLD_PIT_Init(pit1_init_struct);
   \   00000014   0x....             LDR.N    R1,??DataTable8_8
   \   00000016   0xB084             SUB      SP,SP,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x2214             MOVS     R2,#+20
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0xBC0F             POP      {R0-R3}
   \   00000022   0x.... 0x....      BL       LPLD_PIT_Init
    154            
    155            //使能PIT0和PIT1
    156            //LPLD_PIT_EnableIrq(pit0_init_struct);
    157            LPLD_PIT_EnableIrq(pit1_init_struct);
   \   00000026   0x....             LDR.N    R1,??DataTable8_8
   \   00000028   0xB084             SUB      SP,SP,#+16
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000032   0xBC0F             POP      {R0-R3}
   \   00000034   0x.... 0x....      BL       LPLD_PIT_EnableIrq
    158          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    159          

   \                                 In section .text, align 2, keep-with-next
    160          void pit2_init(void)
    161          {
   \                     pit2_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    162            //配置PIT2参数
    163            pit2_init_struct.PIT_Pitx = PIT2;
   \   00000002   0x....             LDR.N    R0,??DataTable8_10
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    164            pit2_init_struct.PIT_PeriodUs = 1; //定时周期1u秒
   \   00000008   0x....             LDR.N    R0,??DataTable8_10
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    165            pit2_init_struct.PIT_Isr = pit2_isr;  //设置中断函数
   \   0000000E   0x....             LDR.N    R0,??DataTable8_10
   \   00000010   0x....             LDR.N    R1,??DataTable8_11
   \   00000012   0x6101             STR      R1,[R0, #+16]
    166            //初始化PIT1
    167            LPLD_PIT_Init(pit2_init_struct);
   \   00000014   0x....             LDR.N    R1,??DataTable8_10
   \   00000016   0xB084             SUB      SP,SP,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x2214             MOVS     R2,#+20
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0xBC0F             POP      {R0-R3}
   \   00000022   0x.... 0x....      BL       LPLD_PIT_Init
    168            LPLD_PIT_EnableIrq(pit2_init_struct);
   \   00000026   0x....             LDR.N    R1,??DataTable8_10
   \   00000028   0xB084             SUB      SP,SP,#+16
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000032   0xBC0F             POP      {R0-R3}
   \   00000034   0x.... 0x....      BL       LPLD_PIT_EnableIrq
    169          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    170          
    171          
    172          
    173          /*
    174           * 初始化UART5模块
    175           *
    176           */

   \                                 In section .text, align 2, keep-with-next
    177          void uart_init(void)
    178          {
   \                     uart_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    179            uart0_init_struct.UART_Uartx = UART0; //使用UART5
   \   00000002   0x....             LDR.N    R0,??DataTable8_12
   \   00000004   0x....             LDR.N    R1,??DataTable8_13  ;; 0x4006a000
   \   00000006   0x6001             STR      R1,[R0, #+0]
    180            uart0_init_struct.UART_BaudRate = 9600; //设置波特率9600
   \   00000008   0x....             LDR.N    R0,??DataTable8_12
   \   0000000A   0xF44F 0x5116      MOV      R1,#+9600
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    181            uart0_init_struct.UART_RxPin = PTB16;  //接收引脚为PTE9
   \   00000010   0x....             LDR.N    R0,??DataTable8_12
   \   00000012   0x2130             MOVS     R1,#+48
   \   00000014   0x7241             STRB     R1,[R0, #+9]
    182            uart0_init_struct.UART_TxPin = PTB17;  //发送引脚为PTE8
   \   00000016   0x....             LDR.N    R0,??DataTable8_12
   \   00000018   0x2131             MOVS     R1,#+49
   \   0000001A   0x7201             STRB     R1,[R0, #+8]
    183            //初始化UART
    184            LPLD_UART_Init(uart0_init_struct);
   \   0000001C   0x....             LDR.N    R1,??DataTable8_12
   \   0000001E   0xB084             SUB      SP,SP,#+16
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000028   0xBC0F             POP      {R0-R3}
   \   0000002A   0x.... 0x....      BL       LPLD_UART_Init
    185          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    186          /*
    187           * 初始化FTM1的正交解码功能
    188           *
    189           */

   \                                 In section .text, align 2, keep-with-next
    190          void qd1_init(void)
    191          {  
   \                     qd1_init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    192            FTM_InitTypeDef ftm_init_struct1;
    193            //配置正交解码功能参数
    194            ftm_init_struct1.FTM_Ftmx = FTM1;              //只有FTM1和FTM2有正交解码功能
   \   00000004   0x....             LDR.N    R0,??DataTable8_14  ;; 0x40039000
   \   00000006   0x9003             STR      R0,[SP, #+12]
    195            ftm_init_struct1.FTM_Mode = FTM_MODE_QD;       //正交解码功能
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xF88D 0x0010      STRB     R0,[SP, #+16]
    196            ftm_init_struct1.FTM_QdMode = QD_MODE_PHAB;    //AB相输入模式
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x001E      STRB     R0,[SP, #+30]
    197            //初始化FTM
    198            LPLD_FTM_Init(ftm_init_struct1);
   \   00000014   0xA903             ADD      R1,SP,#+12
   \   00000016   0xB084             SUB      SP,SP,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x221C             MOVS     R2,#+28
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0xBC0F             POP      {R0-R3}
   \   00000022   0x.... 0x....      BL       LPLD_FTM_Init
    199            //使能AB相输入通道
    200            //PTB0引脚接A相输入、PTB1引脚接B相输入
    201            LPLD_FTM_QD_Enable(FTM1, PTB0, PTB1);
   \   00000026   0x2221             MOVS     R2,#+33
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0x....             LDR.N    R0,??DataTable8_14  ;; 0x40039000
   \   0000002C   0x.... 0x....      BL       LPLD_FTM_QD_Enable
    202          }
   \   00000030   0xB00B             ADD      SP,SP,#+44
   \   00000032   0xBD00             POP      {PC}             ;; return
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void qd2_init(void)
    205          {
   \                     qd2_init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    206            FTM_InitTypeDef ftm_init_struct2;
    207            //配置正交解码功能参数
    208            ftm_init_struct2.FTM_Ftmx = FTM2;              //只有FTM1和FTM2有正交解码功能
   \   00000004   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400b8000
   \   00000006   0x9003             STR      R0,[SP, #+12]
    209            ftm_init_struct2.FTM_Mode = FTM_MODE_QD;       //正交解码功能
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xF88D 0x0010      STRB     R0,[SP, #+16]
    210            ftm_init_struct2.FTM_QdMode = QD_MODE_PHAB;    //AB相输入模式
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x001E      STRB     R0,[SP, #+30]
    211            //初始化FTM
    212            LPLD_FTM_Init(ftm_init_struct2);
   \   00000014   0xA903             ADD      R1,SP,#+12
   \   00000016   0xB084             SUB      SP,SP,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x221C             MOVS     R2,#+28
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0xBC0F             POP      {R0-R3}
   \   00000022   0x.... 0x....      BL       LPLD_FTM_Init
    213            //使能AB相输入通道
    214            //PTB0引脚接A相输入、PTB1引脚接B相输入
    215            LPLD_FTM_QD_Enable(FTM2, PTB18, PTB19);
   \   00000026   0x2233             MOVS     R2,#+51
   \   00000028   0x2132             MOVS     R1,#+50
   \   0000002A   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400b8000
   \   0000002C   0x.... 0x....      BL       LPLD_FTM_QD_Enable
    216          }
   \   00000030   0xB00B             ADD      SP,SP,#+44
   \   00000032   0xBD00             POP      {PC}             ;; return
    217          
    218          /*
    219           * 初始化FTM的PWM输出功能
    220             D4  FTM0CH4
    221             D5  FTM0CH5
    222             D6  FTM0CH6
    223             D7  FTM0CH7
    224           *
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          void pwm_init(void)
    227          {
   \                     pwm_init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    228              FTM_InitTypeDef ftm_init_struct3;
    229              ftm_init_struct3.FTM_Ftmx = FTM0;	//使能FTM0通道
   \   00000004   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40038000
   \   00000006   0x9003             STR      R0,[SP, #+12]
    230              ftm_init_struct3.FTM_Mode = FTM_MODE_PWM;	//使能PWM模式
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF88D 0x0010      STRB     R0,[SP, #+16]
    231              ftm_init_struct3.FTM_PwmFreq = 5000;  
   \   0000000E   0xF241 0x3088      MOVW     R0,#+5000
   \   00000012   0x9005             STR      R0,[SP, #+20]
    232              
    233              LPLD_FTM_Init(ftm_init_struct3);
   \   00000014   0xA903             ADD      R1,SP,#+12
   \   00000016   0xB084             SUB      SP,SP,#+16
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x221C             MOVS     R2,#+28
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000020   0xBC0F             POP      {R0-R3}
   \   00000022   0x.... 0x....      BL       LPLD_FTM_Init
    234              
    235              //FTM0 ch4ch5left ch6ch7right
    236              LPLD_FTM_PWM_Enable(FTM0,FTM_Ch4,0, PTD4,ALIGN_LEFT);
   \   00000026   0x2028             MOVS     R0,#+40
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x2364             MOVS     R3,#+100
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2104             MOVS     R1,#+4
   \   00000030   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40038000
   \   00000032   0x.... 0x....      BL       LPLD_FTM_PWM_Enable
    237              LPLD_FTM_PWM_Enable(FTM0,FTM_Ch5,0, PTD5,ALIGN_LEFT);
   \   00000036   0x2028             MOVS     R0,#+40
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x2365             MOVS     R3,#+101
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x2105             MOVS     R1,#+5
   \   00000040   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40038000
   \   00000042   0x.... 0x....      BL       LPLD_FTM_PWM_Enable
    238              LPLD_FTM_PWM_Enable(FTM0,FTM_Ch6,0, PTD6,ALIGN_LEFT);
   \   00000046   0x2028             MOVS     R0,#+40
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x2366             MOVS     R3,#+102
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x2106             MOVS     R1,#+6
   \   00000050   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40038000
   \   00000052   0x.... 0x....      BL       LPLD_FTM_PWM_Enable
    239              LPLD_FTM_PWM_Enable(FTM0,FTM_Ch7,0, PTD7,ALIGN_LEFT);
   \   00000056   0x2028             MOVS     R0,#+40
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0x2367             MOVS     R3,#+103
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2107             MOVS     R1,#+7
   \   00000060   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40038000
   \   00000062   0x.... 0x....      BL       LPLD_FTM_PWM_Enable
    240          }
   \   00000066   0xB00B             ADD      SP,SP,#+44
   \   00000068   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     adc_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     portc_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x000C0003         DC32     0xc0003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     pit1_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     pit1_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     pit2_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     pit2_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     uart0_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x40039000         DC32     0x40039000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x400B8000         DC32     0x400b8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x40038000         DC32     0x40038000

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    241          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   adc_init
         8   -> LPLD_ADC_Chn_Enable
         8   -> LPLD_ADC_DisableIrq
         8   -> LPLD_ADC_Init
        24   -> __aeabi_memcpy4
      48   init_gpio
        32   -> LPLD_GPIO_EnableIrq
        32   -> LPLD_GPIO_Init
        32   -> __aeabi_memclr4
        48   -> __aeabi_memcpy4
      24   pit1_init
         8   -> LPLD_PIT_EnableIrq
         8   -> LPLD_PIT_Init
        24   -> __aeabi_memcpy4
      24   pit2_init
         8   -> LPLD_PIT_EnableIrq
         8   -> LPLD_PIT_Init
        24   -> __aeabi_memcpy4
      64   pwm_init
        48   -> LPLD_FTM_Init
        48   -> LPLD_FTM_PWM_Enable
        64   -> __aeabi_memcpy4
      64   qd1_init
        48   -> LPLD_FTM_Init
        48   -> LPLD_FTM_QD_Enable
        64   -> __aeabi_memcpy4
      64   qd2_init
        48   -> LPLD_FTM_Init
        48   -> LPLD_FTM_QD_Enable
        64   -> __aeabi_memcpy4
      48   testa15
        32   -> LPLD_GPIO_Init
        32   -> __aeabi_memclr4
        48   -> __aeabi_memcpy4
      24   uart_init
         8   -> LPLD_UART_Init
        24   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant {(GPIO_Type *)0}>
      20  ?<Constant {(GPIO_Type *)0}>_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
     116  adc_init
      20  adc_init_struct
      44  dma_init_struct
      20  gpio_init_struct
     410  init_gpio
      58  pit1_init
      20  pit1_init_struct
      58  pit2_init
      20  pit2_init_struct
     106  pwm_init
      52  qd1_init
      52  qd2_init
      54  testa15
      20  uart0_init_struct
      48  uart_init

 
   144 bytes in section .bss
    40 bytes in section .rodata
 1 022 bytes in section .text
 
 1 022 bytes of CODE  memory
    40 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: none
